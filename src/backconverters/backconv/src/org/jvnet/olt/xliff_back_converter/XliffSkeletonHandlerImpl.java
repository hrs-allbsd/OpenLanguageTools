
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

/*
 * File:           XliffSkeletonHandlerImpl.java
 * Date:           August 13, 2002  11:30 AM
 *
 * @author  kb128066
 * @version generated by NetBeans XML module
 */

package org.jvnet.olt.xliff_back_converter;

import java.io.*;
import java.util.logging.*;
import java.nio.charset.Charset;
//import org.jvnet.olt.utilities.*;
import java.nio.charset.IllegalCharsetNameException;

import org.xml.sax.*;

/**
 * Receives notification of XLIFF Skeleton Parser Events and acts upon
 * those events.
 *
 * <p><code>XliffSkeletonHandlerImpl</code> is an implementation of the
 * <code>XliffSkeletonHandler</code> interface. It receives notification of
 * XLIFF Skeleton Parser Events from the XLIFF Skeleton Parser and merges
 * the transUnits of <code>SegmentedFile</code> objects with the
 * formatting, to output the original file and its formatting.</p>
 *
 * @author    Brian Kidney
 * @version   August 13, 2002
 */

public class XliffSkeletonHandlerImpl implements XliffSkeletonHandler {
    
    /* The SegmentedFile object populated with trans-unit data */
    private SegmentedFile segmentedFile;
    
    /*
     * A logging object
     */
    private static Logger logger = null;
    
    /* Properties required by the Xliff Back Converter */
    private BackConverterProperties props;
    
    private String dir;
    
    private Writer result;
    
    private String charSetString;
    
    /** This flag indicates whether the user requested that the translation status
     * of a segment should be written to the back converted file.
     */
    private boolean writeTransStatus;
    
    /** This flag indicates that a processing instruction should be written to the
     * backconverted file to indicate the translation status. It is set to true if
     * the data type of the file is SGML and the writeTransStatus is true.
     */
    private boolean writeStatusProcInst;
    
    /**
     * This flag indicates the handler encounter the &lt;formatting&gt; element
     */
    private boolean m_isInFormatting = false;
    
    /**
     * This variable is set to store the content for the &lt;formatting&gt; element;
     * including the back converted control character
     */
    private StringBuffer m_formating = new StringBuffer(32);
    
    /** This flag indicates the handler encountered the &lt;formatting&gt; element
     * with a type element set to whitespace.
     */
    private boolean m_inWhiteSpaceFormatting = false;
    
    /** This string stores the last detected piece of formatting. This is used to
     * ensure that the files produced during back conversion are terminated with 
     * a newline character.
     */
    private String m_lastFormattingDetected = "";

    /** This flag is set if the text corresponding to the last tu_placeholder is
     * terminated with a single byte punctuation character. This status is kept 
     * until the next formatting element is encountered. At that point, it is used
     * to determine if the formatting should be written to the output.
     */
    private boolean m_singleBytePunct;
    
    /**
     * Constructor for the XliffSkeletonHandlerImpl object
     */
    public XliffSkeletonHandlerImpl() {
        writeTransStatus = false;
        m_singleBytePunct = false;
    }
    
    /**
     * Constructor for the XliffSkeletonHandlerImpl object
     *
     * @param theLogger  The logging object (For logging messages).
     * @param theProps   Properties required by the Back Converter.
     * @param theDir  The directory where the file is to be saved.
     * @param theCharSetString The character set.
     */
    public XliffSkeletonHandlerImpl(Logger theLogger,
    BackConverterProperties theProps,
    String theDir, String theCharSetString,
    boolean writeTransStatus ) {
        this.writeTransStatus = writeTransStatus;
        this.props = theProps;
        logger = theLogger;
        this.dir = theDir;
        this.charSetString = theCharSetString;
    }
    
    /**
     * Sets the segmentedFile of the XliffSkeletonHandlerImpl
     * object
     *
     * @param theSegmentedFile  The new segmentedFile
     */
    public void setSegmentedFile(SegmentedFile theSegmentedFile) {
        this.segmentedFile = theSegmentedFile;
        String dataType = segmentedFile.getDatatype();
        
        //  Set the writeStatusProcInst flag
        writeStatusProcInst = writeTransStatus && dataType.equalsIgnoreCase("SGML");
    }
    
    /**
     * An event handler indicating the start of a tt-xliff-skl element.
     *
     * Creates a new file writer to write the output to a file with the
     * original filename
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_tt_xliff_skl(final Attributes meta) throws SAXException {
        
        logger.log(Level.FINEST, "start_tt_xliff_skl: " + meta);
        
        try {
            
            // Not using this code, as UnicodeLittle (UCS-2LE) isn't available
            // in java.nio. Instead we trust the user to give us a valid
            // codeset which we use (delivered with java.io instead)
           /* Charset charset = Charset.forName("UTF8");
            if(charSetString != null) {
                charset = Charset.forName(charSetString);
                logger.log(Level.FINE, "charset1 = " + charset.displayName());
            }*/
            
            File origFile = new File(segmentedFile.getOriginalFilename());
        /*  System.out.println("*****************************************");
            System.out.println("dir = "+dir);
            System.out.println("dir qualified name = "+dir + File.separator + origFile.getName());
            System.out.println("strSubDir = "+strSubDir.length());
            System.out.println("Output FileName = "+dir + File.separator + strSubDir+ File.separator+ origFile.getName());
            System.out.println("*****************************************");*/
            
            //  Create the writer for the back conversion
            result = new BufferedWriter(
            new OutputStreamWriter(
            new FileOutputStream(                    
            new File(dir + File.separator + origFile.getName())), charSetString)); //charset.displayName()));
        } catch (java.io.IOException ex) {
            logger.log(Level.SEVERE, "IOException", ex);
            throw new SAXException(ex.getMessage());
        }
    }
    
    /**
     * An event handler indicating the end of a tt-xliff-skl element.
     *
     * Closes the Writer.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_tt_xliff_skl() throws SAXException {
        logger.log(Level.FINEST, "end_tt_xliff_skl()");
        
        try {
            result.flush();
            result.close();
        } catch (java.io.IOException ex) {
            logger.log(Level.SEVERE, "IOException", ex);
            throw new SAXException(ex.getMessage());
        }
    }
    
    /**
     * An event handler indicating the start of a header element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_header(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_header: " + meta);
    }
    
    /**
     * An event handler indicating the end of a header element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_header() throws SAXException {
        logger.log(Level.FINEST, "end_header()");
    }
    
    /**
     * An event handler indicating the start of a file element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_file(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_file: " + meta);
    }
    
    /**
     * An event handler indicating the end of a file element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_file() throws SAXException {
        logger.log(Level.FINEST, "end_file()");
    }
    
    /**
     * An event handler indicating the contents of a tu-placeholder element.
     *
     * The value returned from the getTransUnitValue method of the
     * <code>SegementedFile</code> object is gotten using the value of the
     * "id" attribute of the tu-placeholder as the key. This is then written
     * to the writer.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_tu_placeholder(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_tu_placeholder: " + meta);
        
        try {
            logger.log(Level.FINE, "meta.getValue() = " + meta.getValue("id"));
            TransUnitData transUnit = segmentedFile.getTransUnit(meta.getValue("id"));
            logger.log(Level.FINE, "meta.getValue() = " + transUnit);
            if(transUnit != null) {
                // maintenance note: This next bit of code is a hack. It is SGML
                // specific. What should be done in this situation is to add a
                // parameterized strategy to handle issues like this. Other likely
                // uses of this mechanism would include writing XLIFF notes back to
                // source files, as comments.
                if(writeStatusProcInst) {
                    //  Write the first proc. inst.
                    String openingProcInst = "<?SunTrans translation type=" + transUnit.getTranslationStatus() + ">";
                    result.write(openingProcInst);
                    result.write(transUnit.getText());
                    //  Write the first proc. inst.
                    result.write("<?SunTrans /translation>");
                } else {
                    result.write(transUnit.getText());
                }
                
                //  Do a test here to see if the segment ends in a character that 
                //  should be followed by whitespace, no matter what language we
                //  have.
                m_singleBytePunct = doesTextEndWithPunctuation(transUnit.getText());
            }
        } catch (java.io.IOException ex) {
            logger.log(Level.SEVERE, "IOException", ex);
            throw new SAXException(ex.getMessage());
        }
    }
    
    /** This method determines if a text string ends with on of the following
     * characters: ".", ";", ":", "!", or "?"
     */
    private boolean doesTextEndWithPunctuation(String text) {
        String[] punctChars = { ".", ";", ":", "!", "?" };
        
        for(int i = 0; i < punctChars.length; i++) {
            if(text.endsWith(punctChars[i])) { return true; }
        }
        return false;
    }
    
    /**
     * A container element start event handling method.
     * @param meta attributes
     */
    public void start_formatting(final Attributes meta) throws SAXException {
        
        logger.log(Level.FINEST, "start_formatting: " + meta);
        //  Read the attributes here and set a flag to let us know if this
        //  formatting that is just intersegment whitespace and so can be
        //  ignored for asian languages.
        //System.out.println("------>start_formatting()");
        String formattingTypeString = meta.getValue("type");
        if(formattingTypeString == null) {
            m_inWhiteSpaceFormatting = false;
        } else {
            m_inWhiteSpaceFormatting = (formattingTypeString.equals("whitespace"));
        }
        m_isInFormatting = true;
        m_formating.delete(0, m_formating.length());
    }
    
    /**
     * An event handler indicating the contents of a formatting element.
     *
     * The contents of the element are then written to the writer.
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    
    public void handle_formatting(final java.lang.String data,  final Attributes meta)  throws SAXException {
        logger.log(Level.FINE, "handle_formatting: " + data);
        //System.out.println("------>handle_formatting:"+data);
    }
    
    
    /**
     * A container element end event handling method.
     */
    public void end_formatting() throws SAXException {
        logger.log(Level.FINEST, "end_formatting()");
        
        try {
            //  Here we note the last format detected. When we hit a body close
            //  element we will check this to see if it ends with a newline
            //  character. 
            m_lastFormattingDetected = m_formating.toString();
            
            //  We do not write out the formatting if it is just intersegment 
            //  whitespace, and it is occurring during backconversion to an
            //  Asian file. Some segments will end in characters that should
            //  always be followed by whitespace, however. We check for that here 
            //  too.
            if( !m_inWhiteSpaceFormatting || 
                !isTargetLangAsian(segmentedFile) ||
                 m_singleBytePunct
                ) {
                result.write(m_formating.toString());
            }
        } catch (java.io.IOException ex) {
            logger.log(Level.SEVERE, "IOException", ex);
            throw new SAXException(ex.getMessage());
        }
        m_isInFormatting = false;
    }
    
    /**
     * An event handler indicating the contents of a xliff-file element.
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_xliff_file(final java.lang.String data, final Attributes meta) throws SAXException {
        logger.log(Level.FINE, "handle_xliff_file: " + data);
    }
    
    /**
     * An event handler indicating the start of a body element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_body(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_body: " + meta);
    }
    
    /**
     * An event handler indicating the end of a body element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_body() throws SAXException {
        logger.log(Level.FINEST, "end_body()");
        
        //  Here we check the last formatting we detected to ensure that the 
        //  backconverted files end with a newline.
        if( !m_lastFormattingDetected.endsWith("\n") ) {
            try {
                result.write("\n");
            }
            catch(java.io.IOException ex) {
                logger.log(Level.SEVERE, "IOException", ex);
                throw new SAXException(ex.getMessage());                
            }
        }
    }
    
    /**
     * The CDATA of an element
     *
     * @param values            The characters from the XML document.
     * @param param             The start position in the array.
     * @param param2            The number of characters to read from the
     *                          array.
     * @exception SAXException  Any SAXException
     */
    public void characters(char[] values, int param, int param2) throws SAXException {
        if (m_isInFormatting) {
            m_formating.append(values,param,param2);
        }
    }
    
    /**
     * An event handler indicating the end of the document.
     *
     * @exception SAXException  Any SAXException
     */
    public void endDocument() throws SAXException {
        
    }
    
    /**
     * An event handler indicating the end of an element.
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @param str1              The local name (without prefix), or the
     *                          empty string if Namespace processing is not
     *                          being performed.
     * @param str2              The qualified name (with prefix), or the
     *                          empty string if qualified names are not
     *                          available.
     * @exception SAXException  Any SAXException
     */
    public void endElement(String str, String str1, String str2) throws SAXException {
    }
    
    /**
     * An event handler indicating the end of a prefix mapping.
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @exception SAXException  Any SAXException
     */
    public void endPrefixMapping(String str) throws SAXException {
        
    }
    
    /**
     * An event handler indicating tignorable white space.
     *
     * @param values            The characters from the XML document.
     * @param param             The start position in the array.
     * @param param2            The number of characters to read from the
     *                          array.
     * @exception SAXException  Any SAXException
     */
    public void ignorableWhitespace(char[] values, int param, int param2) throws SAXException {
        
    }
    
    /**
     * An event handler indicating processing instruction.
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @param str1              The local name (without prefix), or the
     *                          empty string if Namespace processing is not
     *                          being performed.
     * @exception SAXException  Any SAXException
     */
    public void processingInstruction(String str, String str1) throws SAXException {
        //System.out.println("=====>processingInstruction");
        if(str.equals(ControlCharacterEscape.INSTRUCTION_CTRLCHAR) && segmentedFile.isSoftwareMsgDatatype()) {
            String data = ControlCharacterEscape.getControlChar(str, str1);
            if (data != null) {
                m_formating.append(data);
            }
        }
    }
    
    /**
     * Sets the documentLocator attribute of the XliffHandlerImpl object
     *
     * @param locator  The new documentLocator value
     */
    public void setDocumentLocator(org.xml.sax.Locator locator) {
        
    }
    
    /**
     * An event handler indicating  a Skipped Entry
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @exception SAXException  Any SAXException
     */
    public void skippedEntity(String str) throws SAXException {
        
    }
    
    /**
     * An event handler indicating the start of a document.
     *
     * @exception SAXException  Any SAXException
     */
    public void startDocument() throws SAXException {
        
    }
    
    /**
     * An event handler indicating the start of a  element.
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @param str1              The local name (without prefix), or the
     *                          empty string if Namespace processing is not
     *                          being performed.
     * @param str2              The qualified name (with prefix), or the
     *                          empty string if qualified names are not
     *                          available.
     * @param attributes        The attributes attached to the element. If
     *                          there are no attributes, it shall be an
     *                          empty Attributes object.
     * @exception SAXException  Any SAXException
     */
    public void startElement(String str, String str1, String str2, org.xml.sax.Attributes attributes)
    throws SAXException {
        
    }
    
    /**
     * An event handler indicating the start of a prefix mapping.
     *
     * @param str               The Namespace prefix being declared
     * @param str1              The Namespace URI the prefix is mapped to.
     * @exception SAXException  Any SAXException
     */
    public void startPrefixMapping(String str, String str1) throws SAXException {
        
    }
    
    protected boolean isTargetLangAsian(final SegmentedFile sf) {
        String lang = sf.getTargetLanguage();
        boolean isAsian = ( lang.equalsIgnoreCase("ja-jp") ||
                            lang.equalsIgnoreCase("zh-cn") ||
                            lang.equalsIgnoreCase("zh-tw") ||
                            lang.equalsIgnoreCase("ko-kr") );
        
        return isAsian;
    }
    
}



