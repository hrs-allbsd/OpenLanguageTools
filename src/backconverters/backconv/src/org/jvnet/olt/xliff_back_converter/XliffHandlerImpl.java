
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

/*
 * File:           XliffHandlerImpl.java
 * Date:           August 8, 2002  1:46 PM
 *
 * @author  kb128066
 * @version generated by NetBeans XML module
 */
package org.jvnet.olt.xliff_back_converter;
import org.xml.sax.*;
import java.io.BufferedReader;
import java.io.File;
import java.io.Reader;
import java.util.logging.*;
import java.net.URL;
import org.jvnet.olt.utilities.FileUtils;


/**
 * Receives notification of XLIFF Parser Events and acts upon those events.
 *
 * <p><code>XliffHandlerImpl</code> is an implementation of the
 * <code>XliffHandler</code> interface. It receives notification of XLIFF
 * Parser Events from the XLIFF Parser and creates
 * <code>SegmentedFile</code> objects based on the data supplied.</p>
 *
 * @author    Brian Kidney
 * @version   August 8, 2002
 * @see       <a href="http://www.oasis-open.org/committees/xliff/">XLIFF Standards Site</a>
 * @see       <a href="http://www.oasis-open.org/committees/xliff/documents/xliff.dtd">XLIFF DTD</a>
 * @see       SegmentedFile
 * @see       SegmentedFileImpl
 */
public class XliffHandlerImpl implements XliffHandler {

    /* The SegmentedFile object to be populated with trans-unit data */
    private SegmentedFile segmentedFile;

    /* Indicates if the current events ancestor element is a trans-unit
     * element (i.e. That the current node that caused the event is a
     * descendant (inside) of the trans-unit element.
     */
    private boolean inTransUnit = false;

    /* Indicates if the current events ancestor element is a source
     * element (i.e. That the current node that caused the event is a
     * descendant (inside) of the source element.
     */
    private boolean inSource = false;

    /* Indicates if the current events ancestor element is a target
     * element (i.e. That the current node that caused the event is a
     * descendant (inside) of the target element.
     */
    private boolean inTarget = false;

    /* A String containing the contents of the current source element. */
    private TransUnitData sourceTU = new TransUnitData();

    /* A String containing the contents of the current target element. */
    private TransUnitData targetTU = new TransUnitData();

    /* Indicates if we are storing the sourceTU.getText() or targetTU.getText() contents
     *  in the SegmentedFile object.
     */
    private boolean isSource = true;

    /* The value of the trans-unit element, "id" attribute. This variable is
     * used as the unique key for the SegmentedFile object setTransUnit
     * method.
     */
    private String transUnitId;

    /* The Xliff Skeleton Parser used for parsing either inline or external
     * Xliff Skeleton elements.
     */
    private XliffSkeletonParser parser;

    /* Used for storing the Xliff Skeleton inline or external file contents
     */
    private BufferedReader reader;

    /* The Implementation of the Xliff Skeleton Handler. */
    private XliffSkeletonHandlerImpl skeletonHandlerImpl;

    /*
     * A logging object
     */
    private static Logger logger = null;

    /* Properties required by the Xliff Back Converter */
    private BackConverterProperties props;

    /* The XLIFF Skeleton file to be read */
    private Reader skeletonFile;

    /* Info about the back conversion */
    private XliffBackConverterInfo backConverterInfo;

    /* The number of trans-units in an xliff file */
    private int numOfTransUnits;

    /* The number of target segments that are being back converted */
    private int numOfTargetUnits;

    
    /**
     * Constructor for the XliffHandlerImpl object
     *
     * @param theLogger  The logging object (For logging messages).
     * @param theProps   Properties required by the Back Converter.
     * @param theParser  The XLIFF Skeleton Parser.
     * @param theSkeletonFile  The XLIFF Skeleton File to be parsed.
     * @param theSkeletonHandlerImpl  The XLIFF Skeleton Handler Impl.
     * @param getSource If True then the source is back converted.
     * otherwise if false the the target is back converted.
     * @param theBackConverterInfo Info about the back conversion
     */
    public XliffHandlerImpl(Logger theLogger,
    BackConverterProperties theProps,
    XliffSkeletonParser theParser,
    Reader theSkeletonFile,
    XliffSkeletonHandlerImpl theSkeletonHandlerImpl,
    boolean getSource,
    XliffBackConverterInfo theBackConverterInfo) {

        this.props = theProps;
        logger = theLogger;
        this.parser = theParser;
        this.skeletonFile = theSkeletonFile;
        this.skeletonHandlerImpl = theSkeletonHandlerImpl;
        this.isSource = getSource;
        this.backConverterInfo = theBackConverterInfo;

    }


    /**
     * Sets the isSource attribute of the XliffHandlerImpl object.
     *
     * The isSource variable indicates if the contents (sourceTU.getText())
     * of source elements is placed in the <code>SegmentedFile</code>
     * object (when isSource = true) or if the contents (targetTU.getText())
     * of target elements is placed in the <code>SegmentedFile</code>
     * object (when isSource = false).
     *
     * isSource = true by default.
     *
     * @param theIsSource  The new isSource value
     */
    public void setIsSource(boolean theIsSource) {
        this.isSource = theIsSource;
    }


    /**
     * An event handler indicating the start of a group element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_group(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_group: " + meta);
    }


    /**
     * An event handler indicating the end of a group element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_group() throws SAXException {
        logger.log(Level.FINEST, "end_group()");
    }


    /**
     * An event handler indicating that an external file has been
     * encountered.
     *
     * When we encounter an external file, the location of the external file
     * is got from the href attribute of the external-file attribute. This
     * file is then opened and read using a Reader.
     *
     * Later in the <code>end_file</code> method, this reader is sent to the
     * <code>XliffSkeletonParser</code> for parsing.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_external_file(final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "handle_external_file: " + meta);
        logger.log(Level.FINEST, "HREF = " + meta.getValue("href"));
        logger.log(Level.FINEST, "SubString = " + meta.getValue("href").substring(8));
        String file = null;
        URL url = null;

        /* If the href is a relative file location (e.g. index.html.skl)
         * then I apend the path to the location of the Skeleton directory
         * (The same directory that the Xliff file was in) to the skeleton
         * file name and create a file reader from this.
         *
         * If onthe other hand the file location is an absolute path
         * (e.g. /home/kb128066/index.html.skl) or if it a URL
         * (e.g. file:///home/kb128066/index.html.skl) then I get the file
         * path and use this to create the file reader.
         */
        /* try {
            URI uri = new URI(meta.getValue("href"));

            if(uri.getScheme() == null) {
                File testParent = new File(uri.getPath());
                if(testParent.getParent() == null) {
                    file = props.getProperty(
                        BackConverterProperties.XLIFF_SKELETON_DIR) + uri.getPath();
                } else {
                    file = uri.getPath();
                }
            } else {
                if(uri.getScheme().equals("file")) {
                    file = uri.getPath();
                }
                try {
                    url = uri.toURL();
                } catch(java.net.MalformedURLException ex) {
                    logger.log(Level.SEVERE, "MalformedURLException ", ex);
                }
            }
        } catch(java.net.URISyntaxException ex) {
            logger.log(Level.SEVERE, "URISyntaxException ", ex);
        }
        logger.log(Level.FINEST, "SubString = " + file);

        try {
            if(file != null) {
                reader = new BufferedReader(new FileReader(file));
            } else {
                reader = new BufferedReader(new InputStreamReader(
                                    url.openStream()));
            }
        } catch (java.io.FileNotFoundException ex) {
            logger.log(Level.SEVERE, "FileNotFoundException ", ex);
        } catch (java.io.IOException ex) {
            logger.log(Level.SEVERE, "IOException", ex);
        } */
    }


    /**
     * An event handler indicating the start of a file element.
     *
     * This event triggers the creation of a new <code>SegemtedFile</code>
     * object and the original filename of the file from before it was
     * segmented (e.g. index.html, docbook.xml, etc.), is set in the new
     * <code>SegemtedFile</code> object.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_file(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_file: " + meta);
        SegmentedFileImpl segmentedFileImpl = new SegmentedFileImpl();
        segmentedFile = segmentedFileImpl;

        logger.log(Level.FINEST, "original filename = " + meta.getValue("original"));
        
        String fileName = null;
        if(props.getBooleanProperty(BackConverterProperties.PROP_GEN_PREFER_XLZ_NAME)){
            fileName = meta.getValue("original");
        }
        else{
            String fname = props.getProperty(BackConverterProperties.PROP_GEN_XLZ_FILE_NAME);
            boolean overwrite = props.getBooleanProperty(BackConverterProperties.PROP_GEN_OVERWRITE_FILES);
            
            File noExtFile = FileUtils.stripExtension(new File(fname),".xlz");
            //if overwriting file, then we don't care much about the name
            if(overwrite){
                fileName = noExtFile.getPath();
            }
            else{
                //no overwriting => make unique name
                File uniqueFile = FileUtils.ensureUniqueFile(noExtFile); 
                fileName = uniqueFile.getPath();
            }
        }
        
        logger.finest("Setting file name to:"+fileName);
        
        segmentedFile.setOriginalFilename(fileName);
        logger.log(Level.FINEST, "data type = " + meta.getValue("datatype"));
        segmentedFile.setDatatype(meta.getValue("datatype"));
        logger.log(Level.FINEST, "target language = " +
        meta.getValue("target-language"));
        
        //  If we are back converting to the target language, we stick the target
        //  language into the segmentedFile data object. Otherwise we stick the
        //  source language code in there.
        if(!isSource) {
            segmentedFile.setTargetLanguage(
            meta.getValue("target-language"));
        } else {
            segmentedFile.setTargetLanguage(
            meta.getValue("source-language"));
        }
    }


    /**
     * An event handler indicating the end of a file element.
     *
     * This event sets the <code>SegmentedFile</code> object in the
     * XliffSkeletonHandler, so that the data from the
     * <code>SegmentedFile</code> object can be merged into the output of
     * the XliffSkeletonParser.
     *
     * This method also sends the reader of the xliff skeleton file from
     * above to the <code>XliffSkeletonParser</code> for parsing.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_file() throws SAXException {
        logger.log(Level.FINEST, "end_file()");

        logger.log(Level.FINEST, "isEmpty() = " + segmentedFile.isEmpty());
        numOfTransUnits = segmentedFile.getNumberOfTransUnits();
        logger.log(Level.FINEST, "Number Of TransUnits = " + numOfTransUnits);

        try {
            skeletonHandlerImpl.setSegmentedFile(segmentedFile);
            parser.parse(new InputSource(skeletonFile));
        } catch (SAXException ex) {
            logger.log(Level.SEVERE, "SAXException", ex);
            throw new SAXException(ex.getMessage());
        } catch (javax.xml.parsers.ParserConfigurationException ex) {
            logger.log(Level.SEVERE, "ParserConfigurationException", ex);
            throw new SAXException(ex.getMessage());
        } catch (java.io.IOException ex) {
            logger.log(Level.SEVERE, "IOException", ex);
            throw new SAXException(ex.getMessage());
        }
    }


    /**
     * An event handler indicating the start of a phase element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_phase(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_phase: " + meta);
    }


    /**
     * An event handler indicating the end of a phase element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_phase() throws SAXException {
        logger.log(Level.FINEST, "end_phase()");
    }


    /**
     * An event handler indicating the start of a ph element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_ph(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_ph: " + meta);
    }


    /**
     * An event handler indicating the contents of a ph element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_ph(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_ph: " + data);
        /*
        if (data != null){
            if (inTransUnit && inSource) {
                sourceTU.appendToText(data);
            } else if (inTransUnit && inTarget) {
                targetTU.appendToText(data);
            }
        }*/
    }


    /**
     * An event handler indicating the end of a ph element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_ph() throws SAXException {
        logger.log(Level.FINEST, "end_ph()");
    }


    /**
     * An event handler indicating the contents of a x element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_x(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_x: " + meta);
    }


    /**
     * An event handler indicating the start of a xliff element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_xliff(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_xliff: " + meta);
        numOfTargetUnits = 0;
    }


    /**
     * An event handler indicating the end of a xliff element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_xliff() throws SAXException {
        logger.log(Level.FINEST, "end_xliff()");
        backConverterInfo.setNumOfTargetUnits(numOfTargetUnits);
        backConverterInfo.setNumOfTransUnits(numOfTransUnits);
        backConverterInfo.setFinished();
    }


    /**
     * An event handler indicating the contents of a ex element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_ex(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_ex: " + meta);
    }


    /**
     * An event handler indicating the contents of a note element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_note(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_note: " + data);
    }


    /**
     * An event handler indicating the contents of a context element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_context(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_context: " + data);
    }


    /**
     * An event handler indicating the start of a phase-group element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_phase_group(final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "start_phase_group: " + meta);
    }


    /**
     * An event handler indicating the end of a phase-group element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_phase_group() throws SAXException {
        logger.log(Level.FINEST, "end_phase_group()");
    }


    /**
     * An event handler indicating the start of a it element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_it(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_it: " + meta);
    }


    /**
     * An event handler indicating the contents of a it element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_it(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_it: " + data);

        if (data != null){
            if (inTransUnit && inSource) {
                sourceTU.appendToText(data);
            } else if (inTransUnit && inTarget) {
                targetTU.appendToText(data);
            }
        }
    }


    /**
     * An event handler indicating the end of a it element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_it() throws SAXException {
        logger.log(Level.FINEST, "end_it()");
    }


    /**
     * An event handler indicating the start of a ept element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_ept(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_ept: " + meta);
    }


    /**
     * An event handler indicating the contents of a ept element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_ept(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_ept: " + data);

        if (data != null){
            if (inTransUnit && inSource) {
                sourceTU.appendToText(data);
            } else if (inTransUnit && inTarget) {
                targetTU.appendToText(data);
            }
        }
    }


    /**
     * An event handler indicating the end of a ept element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_ept() throws SAXException {
        logger.log(Level.FINEST, "end_ept()");
    }


    /**
     * An event handler indicating the start of a g element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_g(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_g: " + meta);
    }


    /**
     * An event handler indicating the contents of a g element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_g(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_g: " + data);

        if (data != null){
            if (inTransUnit && inSource) {
                sourceTU.appendToText(data);
            } else if (inTransUnit && inTarget) {
                targetTU.appendToText(data);
            }
        }
    }


    /**
     * An event handler indicating the end of a g element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_g() throws SAXException {
        logger.log(Level.FINEST, "end_g()");
    }


    /**
     * An event handler indicating the start of a mrk element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_mrk(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_mrk: " + meta);
    }


    /**
     * An event handler indicating the contents of a mrk element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_mrk(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_mrk: " + data);

        if (data != null){
            if (inTransUnit && inSource) {
                sourceTU.appendToText(data);
            } else if (inTransUnit && inTarget) {
                targetTU.appendToText(data);
            }
        }
    }


    /**
     * An event handler indicating the end of a mrk element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_mrk() throws SAXException {
        logger.log(Level.FINEST, "end_mrk()");
    }


    /**
     * An event handler indicating the start of a bpt element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_bpt(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_bpt: " + meta);
    }


    /**
     * An event handler indicating the contents of a bpt element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_bpt(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_bpt: " + data);

        if (data != null){
            if (inTransUnit && inSource) {
                sourceTU.appendToText(data);
            } else if (inTransUnit && inTarget) {
                targetTU.appendToText(data);
            }
        }
    }


    /**
     * An event handler indicating the end of a bpt element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_bpt() throws SAXException {
        logger.log(Level.FINEST, "end_bpt()");
    }


    /**
     * An event handler indicating the contents of a prop element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_prop(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_prop: " + data);
    }


    /**
     * An event handler indicating the start of a body element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_body(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_body: " + meta);
    }


    /**
     * An event handler indicating the end of a body element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_body() throws SAXException {
        logger.log(Level.FINEST, "end_body()");
    }


    /**
     * An event handler indicating the start of a context-group element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_context_group(final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "start_context_group: " + meta);
    }


    /**
     * An event handler indicating the end of a context-group element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_context_group() throws SAXException {
        logger.log(Level.FINEST, "end_context_group()");
    }


    /**
     * An event handler indicating the start of a bin-source element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_bin_source(final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "start_bin_source: " + meta);
    }


    /**
     * An event handler indicating the end of a bin-source element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_bin_source() throws SAXException {
        logger.log(Level.FINEST, "end_bin_source()");
    }


    /**
     * An event handler indicating the start of a glossary element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_glossary(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_glossary: " + meta);
    }


    /**
     * An event handler indicating the end of a glossary element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_glossary() throws SAXException {
        logger.log(Level.FINEST, "end_glossary()");
    }


    /**
     * An event handler indicating the start of a source element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_source(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_source: " + meta);
        inSource = true;
    }


    /**
     * An event handler indicating the contents of a source element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_source(final java.lang.String data,
    final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "handle_source: " + data);

        if(data == null) {
            return;
        }

        if (inTransUnit && inSource && data != null) {
            sourceTU.appendToText(data);
        }
    }


    /**
     * An event handler indicating the end of a source element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_source() throws SAXException {
        logger.log(Level.FINEST, "end_source()");

        inSource = false;
    }


    /**
     * An event handler indicating the start of a bin-target element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_bin_target(final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "start_bin_target: " + meta);
    }


    /**
     * An event handler indicating the end of a bin-target element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_bin_target() throws SAXException {
        logger.log(Level.FINEST, "end_bin_target()");
    }


    /**
     * An event handler indicating the contents of a bx element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_bx(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_bx: " + meta);
    }


    /**
     * An event handler indicating the start of a prop-group element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_prop_group(final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "start_prop_group: " + meta);
    }


    /**
     * An event handler indicating the end of a prop-group element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_prop_group() throws SAXException {
        logger.log(Level.FINEST, "end_prop_group()");
    }


    /**
     * An event handler indicating the start of a skl element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_skl(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_skl: " + meta);
    }


    /**
     * An event handler indicating the end of a skl element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_skl() throws SAXException {
        logger.log(Level.FINEST, "end_skl()");
    }


    /**
     * An event handler indicating the start of a target element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_target(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_target: " + meta);
        inTarget = true;

        if(inTransUnit) {
            numOfTargetUnits = numOfTargetUnits + 1;
        }
    }


    /**
     * An event handler indicating the contents of a target element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_target(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_target: " + data);
        // first check the value of the state attribute
        if(meta != null) {
            String translationStatus = meta.getValue("state");
            if(translationStatus != null) {
                targetTU.setTranslationStatus(translationStatus);
            }
        }
        // this can be if we have a target like:
        // <target xml:lang="ja-JP" state="user:translated"><mrk mtype="phrase"> foo bar </mrk></target>
        if(data == null) {
            return;
        }

        if (inTransUnit && inTarget) {
            targetTU.appendToText(data);
        }

        
    }


    /**
     * An event handler indicating the end of a target element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_target() throws SAXException {
        logger.log(Level.FINEST, "end_target()");
        inTarget = false;
    }


    /**
     * An event handler indicating the contents of a count element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_count(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_count: " + data);
    }


    /**
     * An event handler indicating the start of a header element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_header(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_header: " + meta);
    }


    /**
     * An event handler indicating the end of a header element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_header() throws SAXException {
        logger.log(Level.FINEST, "end_header()");
    }


    /**
     * An event handler indicating the contents of an internal-file element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * Note: Code Needs to be added here to handle internal XLIFF Skeleton
     * files.
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_internal_file(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_internal_file: " + data);
    }


    /**
     * An event handler indicating the start of a reference element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_reference(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_reference: " + meta);
    }


    /**
     * An event handler indicating the end of a reference element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_reference() throws SAXException {
        logger.log(Level.FINEST, "end_reference()");
    }


    /**
     * An event handler indicating the start of a bin-unit element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_bin_unit(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_bin_unit: " + meta);
    }


    /**
     * An event handler indicating the end of a bin-unit element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_bin_unit() throws SAXException {
        logger.log(Level.FINEST, "end_bin_unit()");
    }


    /**
     * An event handler indicating the start of a trans-unit element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_trans_unit(final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "start_trans_unit: " + meta);
        inTransUnit = true;

        transUnitId = meta.getValue("id");
    }


    /**
     * An event handler indicating the end of a trans-unit element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_trans_unit() throws SAXException {
        logger.log(Level.FINEST, "end_trans_unit()");

        if (inTransUnit && isSource) {
            logger.log(Level.FINEST, "Adding sourceTU.getText() to segmentedFile with " +
            "transUnitId = " + transUnitId + " and sourceTU.getText() = " +
            sourceTU.getText());
            segmentedFile.setTransUnit(transUnitId, sourceTU);
        } else if (inTransUnit && !isSource) {
            if(targetTU.getText().equals("")) {
                logger.log(Level.FINEST, "No Target String present. Adding " +
                "sourceTU.getText() to segmentedFile with " +
                "transUnitId = " + transUnitId + " and sourceTU.getText() = " +
                sourceTU.getText());
                segmentedFile.setTransUnit(transUnitId, sourceTU);
            } else {
                logger.log(Level.FINEST, "Adding targetTU.getText() to segmentedFile with " +
                "transUnitId = " + transUnitId + " and targetTU.getText() = " +
                targetTU.getText());
                segmentedFile.setTransUnit(transUnitId, targetTU);

            }
        }
        // fixme:
        targetTU = new TransUnitData();
        sourceTU = new TransUnitData();
        inTransUnit = false;
    }


    /**
     * An event handler indicating the start of a alt-trans element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_alt_trans(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_alt_trans: " + meta);
        inTransUnit = false;
    }


    /**
     * An event handler indicating the end of a alt-trans element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_alt_trans() throws SAXException {
        logger.log(Level.FINEST, "end_alt_trans()");
        inTransUnit = true;
    }


    /**
     * An event handler indicating the start of a count-group element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_count_group(final Attributes meta)
    throws SAXException {
        logger.log(Level.FINEST, "start_count_group: " + meta);
    }


    /**
     * An event handler indicating the end of a count-group element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_count_group() throws SAXException {
        logger.log(Level.FINEST, "end_count_group()");
    }


    /**
     * An event handler indicating the start of a sub element.
     *
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void start_sub(final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "start_sub: " + meta);
    }


    /**
     * An event handler indicating the contents of a sub element.
     *
     * The contents of the element are then concatenated to the sourceTU.getText()
     * and targetTU.getText().
     *
     * @param data              The value or null of the element
     * @param meta           The attributes and their values of the element.
     * @exception SAXException  Any SAXException
     */
    public void handle_sub(final java.lang.String data,
    final Attributes meta) throws SAXException {
        logger.log(Level.FINEST, "handle_sub: " + data);

        if (data != null){
            if (inTransUnit && inSource) {
                sourceTU.appendToText(data);
            } else if (inTransUnit && inTarget) {
                targetTU.appendToText(data);
            }
        }
    }


    /**
     * An event handler indicating the end of a sub element.
     *
     * @exception SAXException  Any SAXException
     */
    public void end_sub() throws SAXException {
        logger.log(Level.FINEST, "end_sub()");
    }


    /**
     * The CDATA of an element
     *
     * @param values            The characters from the XML document.
     * @param param             The start position in the array.
     * @param param2            The number of characters to read from the
     *                          array.
     * @exception SAXException  Any SAXException
     */
    public void characters(char[] values, int param, int param2) throws SAXException {
    }


    /**
     * An event handler indicating the end of the document.
     *
     * @exception SAXException  Any SAXException
     */
    public void endDocument() throws SAXException {
    }


    /**
     * An event handler indicating the end of an element.
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @param str1              The local name (without prefix), or the
     *                          empty string if Namespace processing is not
     *                          being performed.
     * @param str2              The qualified name (with prefix), or the
     *                          empty string if qualified names are not
     *                          available.
     * @exception SAXException  Any SAXException
     */
    public void endElement(String str, String str1, String str2)
    throws SAXException {
    }


    /**
     * An event handler indicating the end of a prefix mapping.
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @exception SAXException  Any SAXException
     */
    public void endPrefixMapping(String str)
    throws SAXException {
    }


    /**
     * An event handler indicating tignorable white space.
     *
     * @param values            The characters from the XML document.
     * @param param             The start position in the array.
     * @param param2            The number of characters to read from the
     *                          array.
     * @exception SAXException  Any SAXException
     */
    public void ignorableWhitespace(char[] values, int param, int param2)
    throws SAXException {
    }


    /**
     * An event handler indicating processing instruction.
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @param str1              The local name (without prefix), or the
     *                          empty string if Namespace processing is not
     *                          being performed.
     * @exception SAXException  Any SAXException
     */
    public void processingInstruction(String str, String str1) throws SAXException {

        if (str.equals(ControlCharacterEscape.INSTRUCTION_CTRLCHAR) && segmentedFile.isSoftwareMsgDatatype()) {
            String data = ControlCharacterEscape.getControlChar(str, str1);
            if (data != null) {
                if (inTransUnit && inSource) {
                    sourceTU.appendToText(data);
                } else if (inTransUnit && inTarget) {
                    targetTU.appendToText(data);
                }
            }
        }

    }


    /**
     * Sets the documentLocator attribute of the XliffHandlerImpl object
     *
     * @param locator  The new documentLocator value
     */
    public void setDocumentLocator(org.xml.sax.Locator locator) {
    }


    /**
     * An event handler indicating  a Skipped Entry
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @exception SAXException  Any SAXException
     */
    public void skippedEntity(String str) throws SAXException {
    }


    /**
     * An event handler indicating the start of a document.
     *
     * @exception SAXException  Any SAXException
     */
    public void startDocument() throws SAXException {
    }


    /**
     * An event handler indicating the start of a  element.
     *
     * @param str               The Namespace URI, or the empty string if
     *                          the element has no Namespace URI or if
     *                          Namespace processing is not being performed.
     * @param str1              The local name (without prefix), or the
     *                          empty string if Namespace processing is not
     *                          being performed.
     * @param str2              The qualified name (with prefix), or the
     *                          empty string if qualified names are not
     *                          available.
     * @param attributes        The attributes attached to the element. If
     *                          there are no attributes, it shall be an
     *                          empty Attributes object.
     * @exception SAXException  Any SAXException
     */
    public void startElement(String str, String str1, String str2,
    org.xml.sax.Attributes attributes)
    throws SAXException {
    }


    /**
     * An event handler indicating the start of a prefix mapping.
     *
     * @param str               The Namespace prefix being declared
     * @param str1              The Namespace URI the prefix is mapped to.
     * @exception SAXException  Any SAXException
     */
    public void startPrefixMapping(String str, String str1)
    throws SAXException {
    }

    public SegmentedFile getSegmentedFile() {
        return segmentedFile;
    }
}

