
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.parsers.MsgFileParser";
  LOOKAHEAD=4;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(MsgFileParser)

package org.jvnet.olt.parsers.MsgFileParser;

// import java.io.*;


public class MsgFileParser
{
  /**
   * A variable indicates if the current message file contains msgid key,
   * ensure this file is not empty file.
   */
  protected boolean encounterMessage = false;
  
  public boolean containMessages()
  {
    return encounterMessage;
  }

  /**
   *  A static method to allow the SCCS version of the file to be read at 
   *  runtime.
   */
  public static final String getVersionInfo()
  {
    return "MSG File Parser - version: 1.28";
  }

  protected boolean boolParsed = false;

  /**
   *  The method is called by other TMCi classes to parse the
   *  current input stream as a Msg file
   *  @exception  ParseException
   */
  public void parse() throws ParseException,Exception
  {

    /* right - I want now to pre/post process the parse tree that results
     * trouble is, where do I do this from ? I expect it's something that
     * should visit each node, and depending on whether it's a "quoted set"
     * it should strip the quote characters from the message.. 
     * 
     * -- I'm going to do the parser 1st, and worry about this detail later
     */

    // OTHER THINGS that should be mentioned, are that I'm returning strings everywhere
    // I'll clean them out when I get a chance - they're useful for debugging I think.


    //  Call top level rule.

    file();
    boolParsed = true;

    // this code invokes the quote removing visitor over the newly build parse tree.

    QuoteRemovingVisitor quoteRemove = new QuoteRemovingVisitor();
    this.walkParseTree(quoteRemove, null);
  }


  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(MsgFileParserVisitor visitor, Object data) throws Exception
  {
    if(boolParsed && (visitor != null))
    {
       //  Get root node of the parse tree
       SimpleNode node =(SimpleNode) jjtree.rootNode();
       node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }

    
  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(MsgFileParser)

/* Comment identifier tokens */
TOKEN :
{
  <LC_COMMENT: "$ @LC@">
}

TOKEN :
{
  <TMC_COMMENT: "$ @TMC@">
}

TOKEN :
{
  <COMMENT: "$">
}

/* Other tokens */
TOKEN :
{
  <SET: ("$set") >
}

TOKEN :
{
  <QUOTE: ("$quote") >
}

TOKEN :
{
  <DELSET: ("$delset") >
}

TOKEN :
{
  <NEWLINE: ["\n", "\r"]>
}

TOKEN :
{
  <SLASHNEWLINE: "\\\n">
}

TOKEN :
{
  <DBLSLASH: "\\" "\\" >
}


TOKEN :
{
  <SLASH: "\\">
}


/* White space */
TOKEN :
{
  <WS: (" " |
	"\t" |
	"\b" |
	"\f") > 
}


/* Generic text tokens */
TOKEN :
{
  <NUMBER: (["0"-"9"])+>
}

TOKEN :
{
  <CHAR: (~["\t"," ","\b","\f","\\","\n","\r", "0"-"9" ]) > 
}



/* 
 *  Hack productions to get tokens into the parser tree. jjtree doesn't put
 *  them in by default. These hacks also update nodes in the parse tree with
 *  the values that the tokens contain.
 *
 *  Extra white spaces maybe exist at the beginning of the file or the lines:
 *  1) before the file                  // This can be filtered by blank_line() production
 *  2) before the "$set"                // Please refer to set_directive() production 
 *         or the comment "$ comments"  //              or comment() production 
 *  3) before the message number        // Please refer to msg_number() production
 *  
 */

/*
 *  Productions
 */
void file():
{}
{
  /*  Add construct for first set */
  ( 
    directive()         | 
    comment_block()     |
    lc_comment_block()  |
    tmc_comment_block() |
    blank_line()
  )*
  first_set()
  /*  Other sets */
  ( 
    directive()         | 
    blank_line()        |
    comment_block()     |
    lc_comment_block()  |
    tmc_comment_block() |
    set() 
  )* 
  <EOF>
}

void first_set():
{}
{
  set() | default_set()
}

void default_set():
{}
{
  //  Note: No set directive
  message()  //  Force at least one message to be present
  ( 
    blank_line()        |
    comment_block()     |
    lc_comment_block()  |
    tmc_comment_block() |
    message()
  )*
}

void set():
{
  Token t;
  String st= "";
  String s = "";
}
{
  s=set_directive()
  newline()
  set_body() 

  { jjtThis.setNodeData(s); }
}


void set_body():
{}
{
  (
    blank_line()        |
    comment_block()     |
    lc_comment_block()  |
    tmc_comment_block() |
    message()
  )*
}

/*
 *  We are now allowing values and white space to be ommitted to
 *  conform to the XPG4 spec. (grrr.)
 */
void message():
{
  boolean hasMessage = false;
  String s="";
}
{
  msg_number() 
  (single_white_space_stored() hasMessage = value()) ?
  newline()

  { 
    if (!encounterMessage) encounterMessage = true; 
    jjtThis.setHasMessage(hasMessage);
  }
 
}

void single_white_space_stored():
{
  String s="";
}
{
  s=single_white_space() { jjtThis.setNodeData(s); }
}

boolean value():
{
  String s="";
  String st="";
}
{
  st=value_on_one() { s+=st; } 
  (st=value_on_many() { s+=st; })* 

  { jjtThis.setNodeData(s); return true; }
}

String value_on_one():
{
  String s="";
  String st="";
}
{ 
  (st=sentence() { s+=st; })? 

  { jjtThis.setNodeData(s); return s; }
}

// this is a bit nasty, since it looks just like a value_on_one
// however, it's used so that I can decide how to remove quotes
// (before, we just used a value_on_one, followed by many optional
// value_on_many strings...)

String value_before_many():
{
  String s="";
  String st="";
}
{ 
  st=sentence() { s+=st; } 

  { jjtThis.setNodeData(s); return s; }
}

String value_on_many():
{ String s="";
  String st="";
  Token t;
}
{
  st=slashnewline() { s+=st; }
  (st=sentence() { s+=st; })? 

  { jjtThis.setNodeData(s); return s; }
}

String sentence():
{
  String s = "";
  String st = "";
}
{
  (
    st=word() { s+=st; }|
    st=slash_char() { s+=st; } |
    st=comment_char() { s+=st; } |
    st=settok() { s+=st; } |
    st=delset() { s+=st; } |
    st=quote() { s+=st; } |
    st=number() { s+=st; } |
    st=white_spaces() { s+=st; }
  )+

  { return s; }
}

void blank_line() :
{
  String s="";
  String st="";
}
{
  ( st=white_spaces() { s+=st; } )?
  st=nonstoring_newline() { s+=st; } 

  { jjtThis.setNodeData(s); }
}

//-----------------
// the various comment handling productions
String comment():
{
  String s = "";
  String st = "";
  Token t;
}
{
  //(st=nonstoring_newline() { s+=st; })? 
  ( st=white_spaces() { s+=st; } )?
  st=comment_char() { s+=st; }  
  (
    st=single_white_space() { s+=st; }
    (st=sentence() { s+=st; } )?
    (st=slashnewline() { s+=st; } )?
  )? 

  { return s; }
}

void comment_block() :
{
  String s = "";
  String st;
}
{
  ( st=comment() { s+=st; } )+ { jjtThis.setNodeData(s); }
}


String lc_comment():
{
  String s = "";
  String st = "";
  Token t;
}
{
  //(st=nonstoring_newline() { s+=st; })? 
  t=<LC_COMMENT> { s+=t.image; }  
  ( st=sentence() { s+=st; } )? 
  ( st=slashnewline() { s+=st; })?
  { return s; } 
}

void lc_comment_block() :
{
  String s = "";
  String st;
}
{
  ( st=lc_comment() { s+=st; } )+ { jjtThis.setNodeData(s); }
}


String tmc_comment():
{
  String s = "";
  String st = "";
  Token t;
}
{
  //(st=nonstoring_newline() { s+=st; } )? 
  t=<TMC_COMMENT> { s+=t.image; }  
  ( st=sentence() { s+=st; } )?
  ( st=slashnewline() { s+=st; })?

  { return s; } 
}

void tmc_comment_block() :
{
  String s = "";
  String st;
}
{
  ( st=tmc_comment() { s+=st; } )+ { jjtThis.setNodeData(s); }
}

//------------------
// the directive() thing is intended for directives that are allowed on their own - it
// doesn't include set_directive, since this requires special treatment (in that
// a set always has a set_body() attached. However, for convenience I've included
// the set_directive() production included below...

void directive():
{
    String s="";
    String st="";
}
{
  (
    (st=nonstoring_newline() { s+=st; } )?
    (st=quote_directive() { s+=st; } | st=delset_directive() { s+=st; })
  )
  { jjtThis.setNodeData(s); }
}


String quote_directive():
{
  String s = "";
  String st = "";
  Token t;
}
{
  (
    st=quote() { s+=st; } 
    ( st=white_spaces() { s+=st; } st=directive_char() { s+=st; })?
    (white_space_stored() )? (directive_comment())?
  ) 
  { return s; }
}

String delset_directive():
{
  String s = "";
  String st = "";
  Token t;
}
{
  st=delset() { s+=st; } 
  white_spaces(){ s+=st; }
  st=delset_number() { s+=st; }
  (white_space_stored())? 
  (directive_comment())?

  { return s; }
}

String delset_number():
{
  String s = "";
}
{
  s=number() { return s; }
}

/************************
 * The format of $set
 * $set n comment
 ***********************/
String set_directive():
{
  String s = "";
  String st = "";
  Token t;
}
{
  // There may be bugs here.
  // Wot - like "here be dragons ?" :-)
  
  ( st=white_spaces() { s+=st; } )?
  st=settok() { s+=st; }
  st=white_spaces() { s+=st; }
  set_number()
  (white_space_stored())?
  (directive_comment())? 

  { return s; }
}

String directive_char():
{
  String s = "";
  Token t;
}
{
  ( 
    (t=<CHAR> { s+=t.image; } | s=number())
  ) 
  { jjtThis.setNodeData(s); return s; }
}

void directive_comment():
{
  String s;
}
{
  s=sentence() 
  { jjtThis.setNodeData(s); }
}




//------------------


void msg_number():
{
  String s = "";
  String st = "";
}
{
  ( st=white_spaces() { s+=st; } )?
  st=number() { s+=st; } 
  { jjtThis.setNodeData(s); }
}

void set_number():
{
  String s = "";
}
{
  s=number() {; } { jjtThis.setNodeData(s); }
}


String number():
{
  String s = "";
  Token t;
}
{
  t=<NUMBER> { s+=t.image; } { return s; }

}



String word():
{
  String s = "";
  Token t;
}
{
  ((t=<CHAR> { s+=t.image; })+) {  return s ; }

}

String white_spaces():
{
  String s = "";
  Token t;
}
{
  (t=<WS> { s+=t.image; })+ { return s; }

}

String single_white_space():
{
  String s = "";
  Token t;
}
{
  (t=<WS> { s+=t.image; }) { return s; }

}

String comment_char():
{
  String s = "";
  Token t;
}
{
  (t=<COMMENT> { s+=t.image; }) { return s; }
}

String slashnewline():
{
  String s = "";
  Token t;
}
{
  (t=<SLASHNEWLINE> { s+=t.image; }) { return s; }

}

String slash_char():
{
  String s = "";
  Token t;
}
{
  ((t=<SLASH> | t=<DBLSLASH>) { s+=t.image; }) { return s; }

}

String quote():
{
  String s = "";
  Token t;
}
{
  (t=<QUOTE> { s+=t.image; }) { return s; }

}

String delset():
{
  String s = "";
  Token t;
}
{
  (t=<DELSET> { s+=t.image; }) { return s; }

}

String settok():
{
  String s="";
  Token t;
}
{
  (t=<SET> { s+=t.image; }) { return s; } 
}


void newline():
{
  String s = "";
  Token t;
}
{
   (t=<NEWLINE> { s+=t.image; }) { jjtThis.setNodeData(s); }
}


String nonstoring_newline():
{
  String s = "";
  Token t;
}
{
   (t=<NEWLINE> { s+=t.image; }) { return s; }
}

void white_space_stored():
{
  String s=""; 
}
{
  s=white_spaces() { jjtThis.setNodeData(s); }
}

