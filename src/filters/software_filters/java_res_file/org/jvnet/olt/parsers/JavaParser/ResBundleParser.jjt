
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.parsers.JavaParser";
  LOOKAHEAD=1024;
  VISITOR = true;
//  JAVA_UNICODE_ESCAPE = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  // USER_CHAR_STREAM = true;
  UNICODE_INPUT = true;
  // DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(ResBundleParser)

package org.jvnet.olt.parsers.JavaParser;

// import java.io.*;

/** 
 * This is a parser to parse java resource bundle files. It was used by the
 * ancient and crap message database, by the not so ancient, but still crap
 * Eptas/TMCi system, and is now being used by the hopefully not-at-all crap
 * SunTrans2. It stands as a credit to John Corrigan, the original author of
 * this parser, that it's still being used !
 * 
 * We're making some significant changes in this class for SunTrans2, as we 
 * want to be able get the message, and just the message, or the key and just
 * the key, rather than all the formatting characters that build up to a key or value.
 * 
 * At the same time, we're also guaranteeing backwards compatibility towards
 * older tools that use this parser.
 *
 * One of the problems we face, is with non-string values, and how we should
 * deal with them eg. messages like :
 *    { "key2", new Integer(42) }
 *
 * Ideally, we'd like to call out the value of that message specially, so
 * that we can immediately highlight it as a special type of message. This was
 * partially done in the "simple_value()" production, unfortunately though, it
 * was re-using productions for ( , ) + , etc. so we've created new non-storing
 * productions for those that can be used instead in simple_value and productions
 * like that. Trouble is, things fall over when we get a message array within
 * a message array : not sure what we do there. (see the comment below by
 * searching for the text "EEK")
 *
 * This is a bit ugly - sorry.
 *
 */
public class ResBundleParser //  implements MesgBDParser
{
  /**
   *  A static method to allow the SCCS version of the file to be read at 
   *  runtime.
   */
  public static final String getVersionInfo()
  {
    return "Resource Bundle Parser - version: $Revision: 1.2 $";
  }

  protected boolean boolParsed = false;

  /**
   *  The method is called by other Message Database classes to parse the
   *  current input stream as a Java Resource Bundle
   *  @exception  ParseException
   */
  public void parse() throws ParseException
  {
    //  Call top level rule.
    file();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(ResBundleParserVisitor visitor, Object data) throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }
  protected void finalize() throws Throwable
  {
//    jj_initialized_once = false;
    super.finalize();
  }
  /**
   *  A reallyhorrible hack to get around the fact that the parser object  
   *  can go out of scope but and thus be unreferenceable and possibly garbage
   *  collected but a new one cannot be created because the static variable
   *  jj_initialized_once is set to true.
   */
  public void resetInitFlag()
  {
//    jj_initialized_once = false;
  }  
}

PARSER_END(ResBundleParser)


/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| "/*@LC@" : IN_LC_COMMENT
| "/*@TMC@" : IN_TMC_COMMENT
| <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
TOKEN : {
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_LC_COMMENT>
TOKEN :
{
  <LC_COMMENT: "*/" > : DEFAULT
}

<IN_TMC_COMMENT>
TOKEN :
{
  <TMC_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,
IN_FORMAL_COMMENT,
IN_MULTI_LINE_COMMENT,
IN_LC_COMMENT,
IN_TMC_COMMENT>
MORE :
{
  < ~[] >
}

/* String literals */
TOKEN :
{
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","u","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* Reserved words */
TOKEN :
{
  <OBJECT: "Object" 
	     ( <WS> |
	       <SINGLE_LINE_COMMENT> |
	       <FORMAL_COMMENT> |
	       <MULTI_LINE_COMMENT> |
	       <LC_COMMENT> |
	       <TMC_COMMENT> )* 
	     <LSQR>
	     ( <WS> |
	       <SINGLE_LINE_COMMENT> |
	       <FORMAL_COMMENT> |
	       <MULTI_LINE_COMMENT> |
	       <LC_COMMENT> |
	       <TMC_COMMENT> )* 
	     <RSQR>
	     ( <WS> |
	       <SINGLE_LINE_COMMENT> |
	       <FORMAL_COMMENT> |
	       <MULTI_LINE_COMMENT> |
	       <LC_COMMENT> |
	       <TMC_COMMENT> )* 
	     <LSQR>
	     ( <WS> |
	       <SINGLE_LINE_COMMENT> |
	       <FORMAL_COMMENT> |
	       <MULTI_LINE_COMMENT> |
	       <LC_COMMENT> |
	       <TMC_COMMENT> )* 
	     <RSQR> > |
  <CLASS: "class"> |
  <PACKAGE: "package"> |
  <IMPORT: "import">
}

/* White space */
TOKEN :
{
  <WS: (" " |
	"\t" |
	"\r" |
	"\n" |
	"\b" |
	"\f")+ > 
}


/* Character Tokens */
TOKEN :
{
  <COMMA: "," > |
  <PLUS: "+" > |
  <LPAREN: "(" > |
  <RPAREN: ")" > |
  <LCURLY: "{" > |
  <RCURLY: "}" > |
  <#LSQR: "[" > |
  <#RSQR: "]" > |
  <ASSIGN: "=" > |
  <SEMICOLON: ";" > |
  <QUOTE: "\"" >  |
  <FSLASH: "/">
}

/* Everything else */
TOKEN :
{
  <OTHER_CHARS: (~[" ","\t","\r","\n","\b","\f",";","(",")",",","\"","{","}","/","="])+  > 
}

/* 
 *  Hack productions to get tokens into the parser tree. jjtree doesn't put
 *  them in by default. These hacks also update nodes in the parse tree with
 *  the values that the tokens contain.
 */
String string_literal_hack():
{Token t;}
{
	t=<STRING_LITERAL>  { jjtThis.setNodeData(t.image); return t.image; }
}
String ns_string_literal_hack():
{Token t;}
{
	t=<STRING_LITERAL>  {return t.image; }
}



void ws_hack():
{Token t;}
{
	t=<WS>  { jjtThis.setNodeData(t.image); }
}
String ns_ws_hack():
{Token t;}
{
	t=<WS>  { return t.image; }
}


String other_chars_hack():
{Token t;}
{
	t=<OTHER_CHARS>  { jjtThis.setNodeData(t.image); return t.image; }
}
String ns_other_chars_hack():
{Token t;}
{
	t=<OTHER_CHARS>  { return t.image; }
}



void object_hack():
{Token t;}
{
	t=<OBJECT>  { jjtThis.setNodeData(t.image); }
}
String ns_object_hack():
{Token t;}
{
	t=<OBJECT>  { return t.image; }
}



void class_hack():
{Token t;}
{
	t=<CLASS>  { jjtThis.setNodeData(t.image); }
}
String ns_class_hack():
{Token t;}
{
	t=<CLASS>  { return t.image; }
}

void package_hack():
{Token t;}
{
	t=<PACKAGE>  { jjtThis.setNodeData(t.image); }
}

void import_hack():
{Token t;}
{
	t=<IMPORT>  { jjtThis.setNodeData(t.image); }
}

void multi_line_comment_hack():
{Token t;}
{
	t=<MULTI_LINE_COMMENT>  { jjtThis.setNodeData(t.image); }
}
String ns_multi_line_comment_hack():
{Token t;}
{
	t=<MULTI_LINE_COMMENT>  { return t.image; }
}


void lc_comment_hack():
{Token t;}
{
	t=<LC_COMMENT>  { jjtThis.setNodeData(t.image); }
}
String ns_lc_comment_hack():
{Token t;}
{
	t=<LC_COMMENT>  { return t.image; }
}


void tmc_comment_hack():
{Token t;}
{
    t=<TMC_COMMENT>  { jjtThis.setNodeData(t.image); }
}
String ns_tmc_comment_hack():
{Token t;}
{
	t=<TMC_COMMENT>  { return t.image; }
}


void single_line_comment_hack():
{Token t; String s="";}
{
	t=<SINGLE_LINE_COMMENT> {s+=t.image;} 
        (t=<WS> {s+=t.image;}
         t=<SINGLE_LINE_COMMENT> {s+=t.image;})*{ jjtThis.setNodeData(s); }
}
String ns_single_line_comment_hack():
{Token t; String s="";}
{
	t=<SINGLE_LINE_COMMENT> {s+=t.image;} 
        (t=<WS> {s+=t.image;}
         t=<SINGLE_LINE_COMMENT> {s+=t.image;})*{ return s; }
}

void formal_comment_hack():
{Token t;}
{
	t=<FORMAL_COMMENT>  { jjtThis.setNodeData(t.image); }
}
String ns_formal_comment_hack():
{Token t;}
{
	t=<FORMAL_COMMENT>  { return t.image; }
}

void comma_hack():
{Token t;}
{
	t=<COMMA>  { jjtThis.setNodeData(t.image); }
}
String ns_comma_hack():
{Token t;}
{
	t=<COMMA>  { return t.image; }
}

void plus_hack():
{Token t;}
{
	t=<PLUS>  { jjtThis.setNodeData(t.image); }
}
String ns_plus_hack():
{Token t;}
{
	t=<PLUS>  { return t.image; }
}

void lparen_hack():
{Token t;}
{
	t=<LPAREN>  { jjtThis.setNodeData(t.image); }
}
String ns_lparen_hack():
{Token t;}
{
	t=<LPAREN>  { return t.image; }
}

void rparen_hack():
{Token t;}
{
	t=<RPAREN>  { jjtThis.setNodeData(t.image); }
}
String ns_rparen_hack():
{Token t;}
{
	t=<RPAREN>  { return t.image; }
}

void lcurly_hack():
{Token t;}
{
	t=<LCURLY>  { jjtThis.setNodeData(t.image); }
}
String ns_lcurly_hack():
{Token t;}
{
	t=<LCURLY>  { return t.image; }
}


void rcurly_hack():
{Token t;}
{
	t=<RCURLY>  { jjtThis.setNodeData(t.image); }
}
String ns_rcurly_hack():
{Token t;}
{
	t=<RCURLY>  { return t.image; }
}


void assign_hack():
{Token t;}
{
	t=<ASSIGN>  { jjtThis.setNodeData(t.image); }
}
String ns_assign_hack():
{Token t;}
{
	t=<ASSIGN>  { return t.image; }
}

void semicolon_hack():
{Token t;}
{
	t=<SEMICOLON>  { jjtThis.setNodeData(t.image); }
}
String ns_semicolon_hack():
{Token t;}
{
	t=<SEMICOLON>  { return t.image; }
}

void fslash_hack():
{Token t;}
{
	t=  <FSLASH>  { jjtThis.setNodeData(t.image); }
}
String ns_fslash_hack():
{Token t;}
{
	t=  <FSLASH>  { return t.image; }
}

/* Productions ***/
void white_sp_or_comment() :
{}
{
  ws_hack()  |
  single_line_comment_hack() |
  formal_comment_hack() |
  multi_line_comment_hack() |
  lc_comment_hack() |
  tmc_comment_hack()
}
String ns_white_sp_or_comment() :
{String st="";
 String s="";
}
{
  (st=ns_ws_hack() {s+=st;} |
  st=ns_single_line_comment_hack() {s+=st;}|
  st=ns_formal_comment_hack() {s+=st;}|
  st=ns_multi_line_comment_hack() {s+=st;}|
  st=ns_lc_comment_hack() {s+=st;}|
  st=ns_tmc_comment_hack() {s+=st;})
  {return s;}
}


/* File  **/
void file() :
{}
{
  
  ((white_sp_or_comment())*  
    package_decl() )?
  ((white_sp_or_comment())* 
   import_decl() )*
   (white_sp_or_comment())* 
   class_decl()
    (white_sp_or_comment())*
    ( semicolon_hack() (white_sp_or_comment())* )? <EOF>
}

/* File header stuff **/
void package_decl() :
{}
{
  package_hack() ws_hack() other_chars_hack() (white_sp_or_comment())* semicolon_hack()
}

void import_decl() :
{}
{
  import_hack() ws_hack() other_chars_hack() (white_sp_or_comment())* semicolon_hack() 
}

/* The class block **/
void class_decl() :
{}
{
  (other_chars_hack() ws_hack())+
  class_hack()
  (other_chars_hack() | comma_hack() | white_sp_or_comment())*
  lcurly_hack()
  class_body()
  rcurly_hack() 
}

void class_body() :
{}
{
  (white_sp_or_comment() |
    method_decl()   |
    resource_array()|
    field_decl()
  )*
}

void method_decl() :
{}
{
  ( other_chars_hack() | object_hack() | (white_sp_or_comment())+)+ 
  lparen_hack()
  (white_sp_or_comment() | other_chars_hack() | comma_hack())* 
  rparen_hack()
    (white_sp_or_comment())*
  block()
}

void block() :
{}
{
  lcurly_hack()
  (block() |
   white_sp_or_comment() |
   other_chars_hack() |
   string_literal_hack() |
   assign_hack() |
   comma_hack() |
   plus_hack() |
   LOOKAHEAD( object_hack() (white_sp_or_comment())* lcurly_hack() (white_sp_or_comment())*  res_line_list()) unnamed_resource_array() |
   lparen_hack() |
   rparen_hack() |
   resource_array() |
   object_hack() |
   semicolon_hack() |
   class_hack() |
   fslash_hack()
  )*
  rcurly_hack()
}
String ns_block() : // Sorry about this !
{String s=""; String st="";}
{
  st=ns_lcurly_hack() {s+=st;}
  (st=ns_block() {s+=st;}|
   st=ns_white_sp_or_comment() {s+=st;}|
   st=ns_other_chars_hack() {s+=st;}|
   st=ns_string_literal_hack() {s+=st;}|
   st=ns_assign_hack() {s+=st;}|
   st=ns_comma_hack() {s+=st;}|
   st=ns_plus_hack() {s+=st;}|
   LOOKAHEAD( st=ns_object_hack() 
              (st=ns_white_sp_or_comment())* st=ns_lcurly_hack()
                (st=ns_white_sp_or_comment() )*
                 st=ns_res_line_list()) 
              st=ns_unnamed_resource_array() |
   st=ns_lparen_hack() |
   st=ns_rparen_hack() |
   st=ns_resource_array() |
   st=ns_object_hack() |
   st=ns_semicolon_hack() |
   st=ns_class_hack() |
   st=ns_fslash_hack() 
  )*
  st=ns_rcurly_hack() {s+=st;}
  {return s;}
}

void field_decl() :
{}
{
  
  (other_chars_hack() (white_sp_or_comment())*)+
  (assign_hack() (string_literal_hack() | method_call() | block() | other_chars_hack() | white_sp_or_comment())+)?
  semicolon_hack()
}

void method_call() :
{}
{
  other_chars_hack() lparen_hack() ( parameters() )? rparen_hack()
}

void parameters() :
{}
{
  acceptable_param() (comma_hack() acceptable_param())*
}
 
void acceptable_param() :
{}
{
  (white_sp_or_comment())*
  (
  other_chars_hack() |
  string_literal_hack() |
  plus_hack() |
  method_call()
    )
  (white_sp_or_comment())*
}


/** The resource block proper **/
void resource_array() :
{}
{
  
  (other_chars_hack() (white_sp_or_comment())+)+
  object_hack()
    (white_sp_or_comment())*
    other_chars_hack() 
    (white_sp_or_comment())*
    assign_hack()
    (white_sp_or_comment())*
    lcurly_hack()
    (white_sp_or_comment())* res_line_list() (white_sp_or_comment())*
    rcurly_hack()
    (white_sp_or_comment())*
  semicolon_hack()

}
String ns_resource_array() :
{String s="";String st="";}
{
  
  (st=ns_other_chars_hack() {s+=st;} (st=ns_white_sp_or_comment() {s+=st;})+)+
  st=ns_object_hack() {s+=st;}
    (st=ns_white_sp_or_comment() {s+=st;})*
    st=ns_other_chars_hack() {s+=st;}
    (st=ns_white_sp_or_comment() {s+=st;})*
    st=ns_assign_hack() {s+=st;}
    (st=ns_white_sp_or_comment() {s+=st;})*
    st=ns_lcurly_hack() {s+=st;}
    (st=ns_white_sp_or_comment() {s+=st;})* st=ns_res_line_list() {s+=st;}
       (st=ns_white_sp_or_comment(){s+=st;})*
    st=ns_rcurly_hack() {s+=st;}
    (st=ns_white_sp_or_comment() {s+=st;})*
  st=ns_semicolon_hack() {s+=st;}
  {return s;}
}

void unnamed_resource_array() :
{}
{
  object_hack()
    (white_sp_or_comment())*
    lcurly_hack()
    (white_sp_or_comment())* res_line_list() (white_sp_or_comment())*
    rcurly_hack()
    (white_sp_or_comment())*
  semicolon_hack()
}
String ns_unnamed_resource_array() :
{String s=""; String st="";}
{
  st=ns_object_hack() {s+=st;}
    (st=ns_white_sp_or_comment() {s+=st;})*
    st=ns_lcurly_hack() {s+=st;}
    (st=ns_white_sp_or_comment() {s+=st;})* st=ns_res_line_list() {s+=st;} (st=ns_white_sp_or_comment() {s+=st;})*
    st=ns_rcurly_hack() {s+=st;}
    (st=ns_white_sp_or_comment() {s+=st;})*
  st=ns_semicolon_hack() {s+=st;}
  {return s;}
}

void res_line_list() :
{}
{
  (res_line() ((white_sp_or_comment())* comma_hack() (white_sp_or_comment())* )? )+ 
}
String ns_res_line_list() :
{String s=""; String st="";}
{
  (st=ns_res_line() {s+=st;} ((st=ns_white_sp_or_comment(){s+=st;})* st=ns_comma_hack(){s+=st;} (st=ns_white_sp_or_comment(){s+=st;})* )? )+ 
  {return s;}
}


void res_line() :
{}
{
  lcurly_hack()
  (white_sp_or_comment())*
  key_value_pair()
  (white_sp_or_comment() |
   comma_hack())*
  (white_sp_or_comment())*
  rcurly_hack() 
}
String ns_res_line() :
{String s=""; String st="";}
{
  st=ns_lcurly_hack() {s+=st;}
  (st=ns_white_sp_or_comment(){s+=st;})*
   // EEK ! What to do if we get a message within a message
   // I think the only thing we can do is to just try and store the
   // message as normal. Not sure what this will result in :-(
   key_value_pair()
  (st=ns_white_sp_or_comment(){s+=st;})*
  (st=ns_comma_hack() {s+=st;} | 
   st=ns_white_sp_or_comment(){s+=st;})*
  st=ns_rcurly_hack() {s+=st;}
  {return s;}
}


void key_value_pair() :
{}
{
  ( quoted_text_key() | simple_key() ) 
    (white_sp_or_comment())*
    comma_hack()
    (white_sp_or_comment())*
  (  simple_value() | quoted_text_value())
}

/**
 * here, we're always storing the layout-free version of the key - that is,
 * we're stripping the quote characters from the beginning and end of the
 * key we're being given each time. This node still gets the normal layout
 * version of the key, but the production key_no_layout below gets populated with
 * the clean copy of the key
 */
void quoted_text_key() :
{
  String s;
  String aggreg="";
  String key_no_layout="";
}
{
  s=string_literal_hack(){aggreg+=s; key_no_layout=s.substring(1,s.length()-1);} 
  ((white_sp_or_comment())* plus_hack() {aggreg+="+";}
   (white_sp_or_comment())*  
   s=string_literal_hack() {aggreg+=s; key_no_layout+=s.substring(1,s.length()-1);} )* 
       { jjtThis.setNodeData(aggreg); key_no_layout(key_no_layout);}
}

/**
 * this stores a simple key
 */
void simple_key() :
{String s;}
{
  s=other_chars_hack(){ jjtThis.setNodeData(s); key_no_layout(s.substring(1,s.length()-1));}
}

/**
 * We're hacking in this production in order to be able to save the
 * plaintext key without any layout whatsoever
 */
void key_no_layout(String key) :
{}{
 {jjtThis.setNodeData(key);}
}

void quoted_text_value() :
{
  Token t;
  String s = "";
  String valueNoLayout="";
}
{
  t=<STRING_LITERAL> {s += t.image; valueNoLayout=t.image.substring(1,t.image.length()-1);} 
  (
   (any_comment() | (t=<WS> {s += t.image;}) )*
   t=<PLUS> {s += t.image;}
   (any_comment() | (t=<WS> {s += t.image;}) )* 
   t=<STRING_LITERAL> {s += t.image; valueNoLayout+=t.image.substring(1,t.image.length()-1);}
  )*  
  { jjtThis.setNodeData(s); value_no_layout(valueNoLayout); }
}

/**
 * We're hacking in this production in order to be able to save the
 * message value without any layout whatsoever
 */
void value_no_layout(String value) :
{}{
 {jjtThis.setNodeData(value); System.out.println("Interesting value is "+value);}
}

/* Convenience production to make the quoted_text_value production simpler */
void any_comment() :
{}
{
  single_line_comment_hack() |
  formal_comment_hack() |
  multi_line_comment_hack() |
  lc_comment_hack() |
  tmc_comment_hack()
}

// why was this called a "simple value" - it's anything but ! :-)
// since it deals with stuff like :
// { "key", "Today is "+new Data() }
// - we're storing these eventually using the complex_value_no_layout
// production.
void simple_value() :
{
 String s="";
 String st="";
}
{
  /*
   *  The section below is to handle messages with function calls
   *  inside. It is a bit of a hack to enable a <STRING_LITERAL>
   *  token to start a "simple_value".
   */
  ( 
   ( st=ns_string_literal_hack() {s+=st;}
     ( st=ns_white_sp_or_comment() {s+=st;})* 
     st=ns_plus_hack() {s+=st;}
     ( st=ns_white_sp_or_comment() {s+=st;})* 
     st=ns_other_chars_hack() {s+=st;})
   | st=ns_other_chars_hack() {s+=st;}
  )
  /*
   *  Tack on whatever...
   */
  (st=ns_white_sp_or_comment() {s+=st;}|
   st=ns_other_chars_hack() {s+=st;}|
   st=ns_string_literal_hack() {s+=st;}|
   st=ns_assign_hack() {s+=st;}|
   st=ns_plus_hack() {s+=st;}|
   st=ns_lparen_hack() {s+=st;}|
   st=ns_rparen_hack() {s+=st;}|
   st=ns_block() {s+=st;}|
   st=ns_comma_hack() {s+=st;}|
   st=ns_object_hack() {s+=st;}|
   st=ns_fslash_hack() {s+=st;})* 
   // Now see what the hell we're left with !
    {complex_value_with_layout(s);}
}

/**
 * We want to call out more complex message values separately, in order to
 * work out what to do with them later down the chain. (probably store them
 * in the database with their layout, and mark them specially in the xliff
 * file - this is awkward)
 */
void complex_value_with_layout(String value) :
{} {
 {jjtThis.setNodeData(value);}
}
