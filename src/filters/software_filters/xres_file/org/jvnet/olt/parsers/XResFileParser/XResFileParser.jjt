
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.parsers.XResFileParser";
  LOOKAHEAD=4;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(XResFileParser)

package org.jvnet.olt.parsers.XResFileParser;

// import java.io.*;


public class XResFileParser //  implements MesgBDParser
{
  protected boolean boolParsed = false;

   public static final String getVersionInfo()
   {
    return "X Resources File Parser - version: $Revision: 1.1 $";
   }

  /**
   *  The method is called by other Message Database classes to parse the
   *  current input stream as a Java Resource Bundle
   *  @exception  ParseException
   */
  public void parse() throws ParseException
  {
    //  Call top level rule.
    file();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(XResFileParserVisitor visitor, Object data) throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }
  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(XResFileParser)


/* Comments */

TOKEN :
{
 <PING: "!">
}


/* Includes */
TOKEN :
{
 <HASH: "#include">
}

/* String literals */

//===============

TOKEN :
{
  <NEWLINE: ["\n", "\r"]>
}

TOKEN :
{
  <EQUALS: ":" >
}

TOKEN :
{
    <SLASHNEWLINE: "\\\n">
}

TOKEN :
{
    <SLASH: "\\">
}

/* White space */
TOKEN :
{
  <WS: (" " |
	"\t" |
	"\b" |
	"\f")+ > 
}


TOKEN :
{

    // I'm currently not allowing "!" in words just for the time being 
  <WORD:  (~["\t"," ","\b","\f","\\",":","!","\n","\r"] )+  >

}

/* String literals */




/* 
 *  Hack productions to get tokens into the parser tree. jjtree doesn't put
 *  them in by default. These hacks also update nodes in the parse tree with
 *  the values that the tokens contain.
 */

/*
 *  Productions
 */
void file():
{}
{
    ( message() | comment() | blank_line() | include())* ( eof_message() | eof_comment() | <EOF> )
}

/*  
 *  We are making values optional here!
 */
void message():
{String s="";}
{
    key() equals() (slashnewline_wrapper())?  ( value() )? newline()  
}

void eof_message():
{String s="";}
{
    key() equals() (slashnewline_wrapper())?  ( value() )? <EOF>  
}


//  We are not adding newline to the text of this production
//  as in most applications it will be picked up in the 
//  newline() production anyway.
void blank_line() :
{
  String s="";
  String st="";
}
{
  ((storing_white_space() { s+=st; } )*
   newline() ) { jjtThis.setNodeData(s); }
}



void key():
{ 
  String s="";
  String st="";
}
{
    st=word() { s+=st;} 
    // ( st=white_space() { s+=st; } 
    //  st=word() { s+=st;}
    //  )*
      { jjtThis.setNodeData(s);}
}


void equals():
{ String s="";
  String st="";}
{
    ((storing_white_space())* st=equals_char() {s+=st;}  (storing_white_space())*) { jjtThis.setNodeData(s);}
}

void value():
{ String s="";
  String st="";}
{
   
     st=sentence()  {s+=st;}  (st=value_on_many()  {s+=st;})* {jjtThis.setNodeData(s);}
}

String value_on_many():
{ String s="";
  String st="";
  Token t;
}
{
     st=slashnewline() {s+=st;} st=sentence() {s+=st;} { jjtThis.setNodeData(s); return s; }
}


String sentence():
{
  String s = "";
  String st = "";
}
{
  (st=slashnewline() {s+=st;} |
   st=word() {s+=st;}|
   st=equals_char() {s+=st;} |
   st=slash_char() {s+=st;} |
   st=comment_char() {s+=st;} |
   st=include_char() {s+=st;} |
   st=white_space() {s+=st;})+  { jjtThis.setNodeData(s); return s; }
}


String comment():
{
  String s="";
  String st="";
}
{
    (st=normal_comment() {s+=st;})+ { jjtThis.setNodeData(s); return s;}

}


String normal_comment():
 {
  String s = "";
  String st = "";
  Token t;
 }
 {
   (st=comment_char() {s+=st;})+  ( st=sentence() {s+=st;} )* (t=<NEWLINE> {s+=t.image;} | st=slashnewline() {s+=st;} ) { return s;}

 }

String include():
 {
  String s = "";
  String st = "";
  Token t;
 }
 {
   (st=include_char() {s+=st;})+  ( st=sentence() {s+=st;} )* (st=newline() {s+=st;} | st=slashnewline() {s+=st;} ) { jjtThis.setNodeData(s); return s;}

 }

String eof_comment():
 {
  String s = "";
  String st = "";
  Token t;
 }
 {
   ((st=comment_char() {s+=st;})+  ( st=sentence() {s+=st;} )*  t=<EOF> {;} ){ jjtThis.setNodeData(s); return s;}

 }

void storing_white_space():
{
    String s="";
}
{
    s=white_space() { jjtThis.setNodeData(s); }
}


String word():
{
 String s = "";
 Token t;
}
{
  (t=<WORD> { s+=t.image;}) {  return s ;}

}

String white_space():
{
 String s = "";
 Token t;
}
{
  (t=<WS> { s+=t.image;}) { return s;}

}


String equals_char():
{
 String s = "";
 Token t;
}
{
  (t=<EQUALS> { s+=t.image;}) { return s; }

}

String comment_char():
{
 String s = "";
 Token t;
}
{
  (t=<PING> {s +=t.image;}) { return s;}
}

String include_char():
{
 String s = "";
 Token t;
}
{
  (t=<HASH> {s +=t.image;}) { return s;}
}

String slashnewline():
{
 String s = "";
 Token t;
}
{
  (t=<SLASHNEWLINE> { s+=t.image;}) { return s;}

}

//  This is a complete hack to get the text of a slashnewline 
//  into the parse tree in one particular area.
void slashnewline_wrapper():
{
 String s = "";
}
{
  s=slashnewline() { jjtThis.setNodeData(s); }

}

String slash_char():
{
 String s = "";
 Token t;
}
{
  (t=<SLASH> { s+=t.image;}) { return s;}

}


String newline():
{
  String s = "";
  Token t;
}
{
   (t=<NEWLINE> { s+=t.image;}) { jjtThis.setNodeData(s); return s;}
}
