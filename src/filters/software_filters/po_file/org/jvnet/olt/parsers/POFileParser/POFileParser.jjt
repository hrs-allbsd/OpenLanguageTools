
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.parsers.POFileParser";
  LOOKAHEAD=4;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(POFileParser)

package org.jvnet.olt.parsers.POFileParser;

// import java.io.*;

public class POFileParser //  implements MesgBDParser
{

  /**
   *  A static method to allow the SCCS version of the file to be read at 
   *  runtime.
   */
  public static final String getVersionInfo()
  {
    return "PO File Parser - version: $Revision: 1.1 $";
  }
 
  // variables for GNU PO file
  private int iMsgidCounter = 0;                       // The counter of msgid
  private String sFirstMsgid = null;                   // It contains the msgid text for the first msgid
  private String sFirstMsgstr = null;                  // It contains the msgstr text for the first msgstr
  private boolean isGNUPOParser = false;               // A flag indicate the parser is GNU PO parser
  private boolean pastGNUProductions = false;          // A flag indicate the parser has past any GNU PO production
  private boolean encounteredGNUProductions = false;   // A flag indicate the parser encounters one GNU po production
  public String GNUPO_ERROR_MESSAGE = "Found GNU-specific productions in a Solaris .po file";

  public void setIsGNUPOParser(boolean value)
  {
    this.isGNUPOParser = value;
  }

  public boolean isGNUPOParser()
  {
    return isGNUPOParser;
  }

  protected boolean boolParsed = false;

  /**
   *  The method is called by other Message Database classes to parse the
   *  current input stream as a Java Resource Bundle
   *  @exception  ParseException
   */
  public void parse() throws ParseException
  {
    //  Call top level rule.
    file();
    boolParsed = true;
    if(pastGNUProductions && !isGNUPOParser){
        throw new ParseException(GNUPO_ERROR_MESSAGE);
    }
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(POFileParserVisitor visitor, Object data) throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }
  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(POFileParser)


/* COMMENTS */
  /* LC comment */
MORE :
{
  "#@LC@" : IN_LC_COMMENT
}

<IN_LC_COMMENT>
TOKEN :
{
  <LC_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_LC_COMMENT>
MORE :
{
  < ~[] >
}

/* TMC comments */
MORE :
{
  "#@TMC@" : IN_TMC_COMMENT
}

<IN_TMC_COMMENT>
TOKEN :
{
  <TMC_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_TMC_COMMENT>
MORE :
{
  < ~[] >
}

  /* base comments */
MORE :
{
  "#" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
  < ~[] >
}




/* String literals */
TOKEN :
{
  < STRING_LITERAL:
      "\""
      ( (~["\"","\n","\r"] )
        | ("\\" "\"" )
 	)*
      "\""
  >
}

/* Reserved words */
TOKEN :
{
  <DOMAIN: "domain"> |
  <MSGID: "msgid"> |
  <MSGSTR: "msgstr"> |
  <MSGID_PLURAL: "msgid_plural"> |
  <MSGSTRS: ("msgstr[0]" | "msgstr[1]" | "msgstr[2]")>
}

/* White space */
TOKEN :
{
  <WS: (" " |
	"\t" |
	"\r" |
	"\b" |
	"\f")+ > 
}

TOKEN :
{
  <NEWLINE: "\n">
}


/* 
 *  Hack productions to get tokens into the parser tree. jjtree doesn't put
 *  them in by default. These hacks also update nodes in the parse tree with
 *  the values that the tokens contain.
 */

/*
 *  Productions
 */
void file() :
{}
{
  ( 
   domain() |
   comment_hack() |
   lc_comment_hack() |
   tmc_comment_hack() |
   newline_hack() |
   message() 
  )+ 
  <EOF>
}

void lc_comment_hack():
{Token t;
 String s = "";
}
{
	(t=<LC_COMMENT> {s+=t.image;} )+ { jjtThis.setNodeData(s); }
}

void tmc_comment_hack():
{Token t;
 String s = "";
}
{
	(t=<TMC_COMMENT> {s+=t.image;} )+ { jjtThis.setNodeData(s); }
}

void comment_hack():
{Token t;
 String s = "";
}
{
	(t=<SINGLE_LINE_COMMENT> {s+=t.image;} )+ { jjtThis.setNodeData(s); }
}

void ws_hack():
{
  Token t;
}
{
  t=<WS> {jjtThis.setNodeData(t.image);} 
}

void newline_hack():
{
  String s = "";
  Token t;
}
{
   (t=<NEWLINE> { s+=t.image;}) { jjtThis.setNodeData(s);}
}

void message():
{
  boolean hasMsgStr = false;
}
{
  message_id() (comment_hack() | newline_hack() )* hasMsgStr=message_string()
  { 
    jjtThis.setHasMsgStr(hasMsgStr); 
    // Need to judge the type of the current po file
    if (iMsgidCounter == 1) {
      setIsGNUPOParser(sFirstMsgid != null && 
                       sFirstMsgid.equals("\"\"") &&
                       sFirstMsgstr != null &&
                       sFirstMsgstr.toLowerCase().indexOf("charset") != -1);
    }
  }
}

/**
 *  Message ID stuff
 */
void message_id():
{}
{
  msgid_hack() ws_hack() msgid_text() newline_hack()
  (msgid_plural_hack() ws_hack() msgid_text() newline_hack())?
}

void msgid_hack():
{
  Token t;
}
{
  t=<MSGID> 
  {
    ++iMsgidCounter; // Increase the counter with 1 if match 'msgid'
    jjtThis.setNodeData(t.image);
  }
}

void msgid_text():
{
  String s = "";
  String key = "";
  Token t;
  String[] arr;
}
{
  t=<STRING_LITERAL> { s+=t.image; key = t.image; } 
  ( 
     ( t=<WS> { s+=t.image;} )?
     arr=message_line(key) { s+= arr[0]; key = arr[1];} 
  )*  
  (<WS>)?
  { 
    jjtThis.setNodeData(s);
    jjtThis.setKeyData(key);
    // Record the msgid string for the first msgid
    if (iMsgidCounter == 1 && sFirstMsgid == null)
      sFirstMsgid = new String(key);
  }
}

/**
 *  Message String stuff
 */
boolean message_string():
{ // this is bad - we only support a few plural forms
  boolean hasMsgStr = false;
  boolean hasMsgStr0 = false;
  boolean hasMsgStr1 = false;
  boolean hasMsgStr2 = false;
}
{
  (
    //  Standard Solaris .po msgstr syntax
    ( 
      msgstr_hack() 
      (hasMsgStr=msgstr_text())? 
      newline_hack()
      {
        if (encounteredGNUProductions) {
          throw new ParseException("Error in GNU .po file: the msgid_plural syntax NOT available."); 
        }
      }
    ) |
    //  GNU .po msgstr syntax
    ( 
      msgstr_plural_hack() 
      (hasMsgStr0=msgstr_text())? 
      newline_hack() 
      
      (msgstr_plural_hack() 
      (hasMsgStr1=msgstr_text())? 
      newline_hack())?

      (msgstr_plural_hack() 
      (hasMsgStr2=msgstr_text())? 
      newline_hack())?



      { 
        if(!hasMsgStr0 && hasMsgStr1)
          throw new ParseException("Error in GNU .po file: the msgstr format NOT available.\n"+
                                    "Try to use the below format:\n"+
                                    "msgstr[0] \"\"\n"+
                                    "msgstr[1] \"\"\n"+
                                    "Or\n"+
                                    "msgstr[0]\n"+
                                    "msgstr[1]\n");
        if (!encounteredGNUProductions) 
          throw new ParseException("Error in GNU .po file: the msgid_plural syntax NOT available."); 
        if (encounteredGNUProductions) 
          encounteredGNUProductions = false; 
        hasMsgStr = hasMsgStr0 || hasMsgStr1 || hasMsgStr2;
      }
    )
  )
  { return hasMsgStr; }
}

void msgstr_hack():
{
  String s = "";
  Token t;
}
{
  t=<MSGSTR> { s+=t.image; }
  (t=<WS> { s+=t.image; })?
  { jjtThis.setNodeData(s); }  
}

boolean msgstr_text():
{
  String s = "";
  // this builds up the value of the msgstr without the layout
  String sNoLayout = "";
  String[] arr;
  Token t;
}
{
  t=<STRING_LITERAL> {
    s+=t.image; sNoLayout = t.image;
  } 
  ( 
    ( t=<WS> { s+=t.image;})? 
    arr=message_line(sNoLayout) {s+=arr[0]; sNoLayout=arr[1];} // arr[0] here is the string inc. layout
  )*
  (<WS>)? 

  { 
    jjtThis.setNodeData(s); 
    msgstr_unformatted_text(sNoLayout);
    // Record the msgstr text for the first msgstr
    if (iMsgidCounter == 1 && sFirstMsgstr == null)
      sFirstMsgstr = new String(sNoLayout);
    return true;
  }
}

// this is a nasty hack to store the unformatted text of a message
// somewhere in the parse tree. Sorry !
void msgstr_unformatted_text(String text):
{ }{
{ jjtThis.setNodeData(text);}
}

// this function gets called many times by both the message id and message
// value productions, once per line of message
// key/value and returns an array containing the current text of the
// key/value  (no file layout characters) and the also the message
// entry including file layout as it's being built up.

// SunTrans2 drops the file layout stuff, so when we ask for the value
// of a message, we get the value of the message, without the message
// file layout. The msgstr_text production still retains the original
// formatting of the message string though.

// this is also slightly confusing, the parameter "key" that's being passed
// in here, is in fact the "layout version" text, that gets stripped of it's layout
// and returned each time. It's used to determine the no-layout version of
// either the msgid or the msgstr text.
String[] message_line(String key):
{
  String s = "";
  String[] array = new String[2];  
  Token t;
}
{
  (t=<NEWLINE> {s+=t.image;}
  (t=<WS> {s+=t.image;})? 
  t=<STRING_LITERAL> { 
    s+=t.image; 
    String strB = t.image;
    if(!key.equals(""))
    {	
       key = key.substring(0,key.length() - 1);   //  Remove the first and last double quote 
       strB = strB.substring(1,strB.length());    //  Remove the first double quote 
                                                  //  this was done differently in ST1
     }
     key += strB;     //  Concatenate the strings 
  } 
  ) { 
   
    array[0] = s;
    array[1] = key;
    return array;
  }
}

/**
 *  Domain stuff
 */
void domain():
{}
{
  domain_hack() ws_hack() domain_text()  newline_hack()
}

void domain_hack():
{
  Token t;
}
{
  t=<DOMAIN> {jjtThis.setNodeData(t.image);}
}

void domain_text():
{
  String s="";
  Token t;
}
{
  (t=<STRING_LITERAL> { s+=t.image;} 
  ( t=<WS> { s+=t.image;})? 
  ) { jjtThis.setNodeData(s); }
}

/**
 * GNU PO productions
 */
void msgid_plural_hack():
{
  Token t;
}
{
  t=<MSGID_PLURAL> 
  { 
    ++iMsgidCounter; // Increase the counter with 1 if match 'msgid'
    pastGNUProductions = true;
    encounteredGNUProductions = true; 
    //System.out.println("=====> encounteredGNUProductions =" + encounteredGNUProductions);
    //System.out.println("=====> isGNUPOParser =" + isGNUPOParser);
    
    jjtThis.setNodeData(t.image); 
  }
}

void msgstr_plural_hack():
{
  String s = "";
  Token t;
}
{
  t=<MSGSTRS> { s+=t.image; }  
  (t=<WS> { s+=t.image; })?
  { jjtThis.setNodeData(s); }  

}
