
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.parsers.PropsFileParser";
  LOOKAHEAD=4;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(PropsFileParser)

package org.jvnet.olt.parsers.PropsFileParser;

// import java.io.*;


public class PropsFileParser //  implements MesgBDParser
{
  /**
   * A variable indicates if the current message file contains msgid key,
   * ensure this file is not empty file.
   */
  protected boolean encounterMessage = false;
  
  public boolean containMessages()
  {
    return encounterMessage;
  }

  /**
   *  A static method to allow the SCCS version of the file to be read at 
   *  runtime.
   */
  public static final String getVersionInfo()
  {
    return "Properties File Parser - version: 1.12";
  }

  protected boolean boolParsed = false;

  /**
   *  The method is called by other Message Database classes to parse the
   *  current input stream as a Java Resource Bundle
   *  @exception  ParseException
   */
  public void parse() throws ParseException
  {
    //  Call top level rule.
    file();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(PropsFileParserVisitor visitor, Object data) throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }
  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(PropsFileParser)

/* COMMENTS */
// This is JC's method of doing comments that I'm experimenting with a differnt version despite - this works for .po files.
//  MORE :
//  {
//   "#" : IN_SINGLE_LINE_COMMENT
//  }
 
//  <IN_SINGLE_LINE_COMMENT>
//  TOKEN :
//  {
//   <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
//  }
 
//  <IN_SINGLE_LINE_COMMENT>
//  MORE :
//  {
//   < ~[] | "#" >
//  }
 

/* COMMENTS */
TOKEN :
{
  <#COMMENT_CHAR: ["!", "#"]>
}

TOKEN :
{
  <COMMENT: <COMMENT_CHAR> >
}

TOKEN :
{
  <LC_COMMENT: <COMMENT_CHAR> "@LC@">
}

TOKEN :
{
  <TMC_COMMENT: <COMMENT_CHAR> "@TMC@">
}

//===============

TOKEN :
{
  <NEWLINE: "\n">
}

TOKEN :
{
  <WIN32NEWLINE: "\r\n" >
}


TOKEN :
{
  <EQUALS: ["=", ":"] >
}

TOKEN :
{
  <SLASHNEWLINE: "\\\n">
}

TOKEN :
{
  <WIN32SLASHNEWLINE: "\\\r\n" >
}

TOKEN :
{
  <SLASH: "\\">
}

/* White space */
TOKEN :
{
  <WS: (" " | "\t" | "\b" | "\f")+ > 
}


TOKEN :
{
  // I'm currently not allowing "#" and "!" in words just for the time being 
  <WORD:  ("\\=" | "\\:" | "\\ " | "\\\t" | "\\\f" | "\\!" | ~["\t"," ","\b","\f","=","\\",":","#","!","\n","\r"] )+  >
}

/* String literals */





/*
 *  Productions
 */
void file():
{}
{
  (
    message() |
    normal_comment_block() |
    lc_comment_block() |
    tmc_comment_block() |
    blank_line() 
  )* 
  <EOF>
}

// This is the main production.

void message():
{
  boolean hasMessage = false;
  String s="";
}
{
  ( white_space() )? key() ( equals() )? ( slashnewline_stored() )* ( hasMessage=value() )? 

  { 
    if (!encounterMessage) encounterMessage = true; 
    jjtThis.setHasMessage(hasMessage);
  }
}

void key():
{
  String s="";
}
{
  s=word() { jjtThis.setNodeData(s); }
}


void equals():
{ 
  String s="";
  String st="";
}
{
  ( st=white_space() {s+=st;} )? 
  st=equals_char() {s+=st;} 
  ( st=white_space() {s+=st;} )?
  { jjtThis.setNodeData(s); }
}



boolean value():
{
  String s="";
  String st="";
  String valueNoLayout = "";
}
{
  st=sentence()  {s+=st; valueNoLayout=st;}  
  // we're setting s to be the value including the layout and we're stripping
  // the "/\n" sequence from the beginning of the value_on_many() results to build up
  // the string without the layout.
  ( st=value_on_many()  {s+=st; valueNoLayout+=st.substring(2,st.length());} )* 
  ( st=newline() {s+=st;} )?
  { jjtThis.setNodeData(s); value_no_layout(valueNoLayout);  return true; }  // This allows for null values
}

void value_no_layout(String value):
{}
{
  { jjtThis.setNodeData(value); }
}

String value_on_many():
{
  String s="";
  String st="";
  Token t;
}
{
  st=slashnewline() {s+=st;} 
  (st=sentence() {s+=st;} )?
  { jjtThis.setNodeData(s); return s; }
}


String sentence():
{
  String s = "";
  String st = "";
}
{
  ( st=word() {s+=st;} |
    st=equals_char() {s+=st;} |
    st=slash_char() {s+=st;} |
    st=comment_char() {s+=st;} |
    st=lc_comment_char() {s+=st;} |
    st=tmc_comment_char() {s+=st;} |
    st=white_space() {s+=st;}
  )+
  { jjtThis.setNodeData(s); return s; }
}

String word():
{
  String s = "";
  Token t;
}
{
  ( t=<WORD> {s+=t.image;} ) {  return s ; }
}

String white_space():
{
  String s = "";
  Token t;
}
{
  ( t=<WS> { s+=t.image;} ) { jjtThis.setNodeData(s);return s; }
}

String equals_char():
{
  String s = "";
  Token t;
}
{
  ( t=<EQUALS> {s+=t.image;} ) { return s; }
}

String slashnewline():
{
  String s = "";
  Token t;
}
{
  (( t=<WIN32SLASHNEWLINE> {s+=t.image;} ) |
  ( t=<SLASHNEWLINE> {s+=t.image;} ))  { return s; }
}

void blank_line() :
{
  String s="";
  String st="";
}
{

  ( ( st=white_space() {s+=st;} )? st=newline() {s+=st;} ) { jjtThis.setNodeData(s); }
}

/*
 *  This production is included to deal with a few special cases
 *  where text needs to be stored in the slashnewline node rather
 *  than passed on to the parent node.
 */
void slashnewline_stored():
{
  String s = "";
  Token t;
}
{
  ( s=slashnewline() ) { jjtThis.setNodeData(s); }
}

String slash_char():
{
  String s = "";
  Token t;
}
{
  ( t=<SLASH> {s+=t.image;} ) { return s; }
}

String newline():
{
  String s = "";
  Token t;
}
{
  (( t=<NEWLINE> {s+=t.image;} ) |
  ( t=<WIN32NEWLINE> {s+=t.image;} )) { jjtThis.setNodeData(s); return s; }
}

//---------------------------------------------------------
//  The comment characters
String comment_char():
{
  String s = "";
  Token t;
}
{
  ( t=<COMMENT> {s +=t.image;} ) { return s; }
}

String lc_comment_char():
 {
 String s = "";
  Token t;
}
{
  ( t=<LC_COMMENT> {s +=t.image;} ) { return s; }
}

String tmc_comment_char():
{
  String s = "";
  Token t;
}
{
  ( t=<TMC_COMMENT> {s +=t.image;} ) { return s; }
}


//--------------------------------------------------------
//  Prouctions for all the various comment types
//   - Normal comments
String normal_comment_block():
{
  String s="";
  String st="";
}
{
  ( st=normal_comment() {s+=st;} )+ 
  { jjtThis.setNodeData(s); return s; }
}


String normal_comment():
{
  String s = "";
  String st = "";
  Token t;
}
{
  ( 
    ( ( st=white_space() { s+=st; } )? st=comment_char() {s+=st;} )+  
    ( st=sentence() {s+=st;} 
      ( st=slashnewline() {s+=st;} ( st=sentence() {s+=st;} )? )* )? 
    ( st=newline() {s+=st;} )?
  )
  { jjtThis.setNodeData(s); return s; }
}

//   - LC comments
String lc_comment_block():
{
  String s="";
  String st="";
}
{
  ( st=lc_comment() {s+=st;} )+ 
  { jjtThis.setNodeData(s); return s; }
}


String lc_comment():
{
  String s = "";
  String st = "";
  Token t;
}
{
  (
    ( ( st=white_space() { s+=st; } )? st=lc_comment_char() {s+=st;} )+  
    ( st=sentence() {s+=st;} )?
    //( st=slashnewline() {s+=st;} ( st=sentence() {s+=st;} )? )* 
    ( st=newline() {s+=st;} )?
  )
  { jjtThis.setNodeData(s); return s; }
}

//   - TMC comments
String tmc_comment_block():
{
  String s="";
  String st="";
}
{
  ( st=tmc_comment() {s+=st;} )+ 
  { jjtThis.setNodeData(s); return s; }
}


String tmc_comment():
{
  String s = "";
  String st = "";
  Token t;
}
{
  (
    ( ( st=white_space() { s+=st; } )? st=tmc_comment_char() {s+=st;} )+  
    ( st=sentence() {s+=st;} )?
    //( st=slashnewline() {s+=st;} ( st=sentence() {s+=st;} )? )* 
    ( st=newline() {s+=st;} )?
    //( st=sentence() {s+=st;} )* 
    //( st=newline() {s+=st;} | st=slashnewline() {s+=st;} )
  )
  { jjtThis.setNodeData(s); return s; }
}

