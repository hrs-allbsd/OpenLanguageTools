
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */


options{
  NODE_PACKAGE = "org.jvnet.olt.filters.NonConformantSgmlTagParser";
  LOOKAHEAD=9;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(NonConformantSgmlTagParser)

package org.jvnet.olt.filters.NonConformantSgmlTagParser;


public class NonConformantSgmlTagParser
{
  protected boolean boolParsed = false;

  /**
   *  @exception  ParseException
   */
  public void parse()
    throws ParseException
  {
    //  Call top level rule.
    tag();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(NonConformantSgmlTagParserVisitor visitor, Object data)
    throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }
  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(NonConformantSgmlTagParser)



TOKEN :
{
        <STAG:   "<" >
|       <CLOSETAG: "</" >
|       <XMLETAG: "/>" >
|       <ETAG:   ">" >
}

TOKEN :
{
       <#LETTER:   ["a"-"z","A"-"Z"]   >
|       <#NUM:		["0"-"9"]			>
|       <#NCNAMECHAR:	(<LETTER> | <NUM> | "." | "-" | "_" ) >
|       <PREFIX:   ( <NCNAME> ) ( ":" ) > 
|       <NCNAME:   ( <LETTER> | "_" ) ( <NCNAMECHAR> )*  > 
|       <EQ:            "="                             >
|       <STRING_LIT:    ("'" ( ~["'"] )* "'" | "\"" ( ~["\""] )* "\"" ) >
|       <UNQUOTED_STRING:  ( ~["<", ">",  "\"", "'", "=",
                                "\t", " ", ":", "\n", "\b", "\f", "\r" ] ) > 
}

TOKEN :
{
  <WS: ( "\t" |
         " "  | 
         "\n" |
         "\b" |
         "\f" |
         "\r" )+ > 
}


//  Productions
void tag() :
{}
{
  stag()
 ( ws() )?
  (tagname())?
  ( attlist() )?
  ( ws() )?
  etag()
}

void stag() :
{
  Token t;
}
{
  (t=<STAG> | t=<CLOSETAG>) { jjtThis.setNodeData(t.image); } 
}

void etag() :
{
  Token t;
}
{
  (t=<XMLETAG> | t=<ETAG>) { jjtThis.setNodeData(t.image); } 
}

void ws() :
{
  Token t;
}
{
  t=<WS> { jjtThis.setNodeData(t.image); } 
}

void tagname() :
{
  Token t;
}
{
  (t=<NCNAME> { jjtThis.setNodeData(t.image); }  
  | ( t=<PREFIX> { jjtThis.setPrefix(t.image); }
      t=<NCNAME> { jjtThis.setNodeData(t.image); }))
}

void attlist() :
{}
{  // making the attributes optional for <img src="foo.gif" NOSAVE > Netscape specific html
   ( ws() (ws())* attname() ((ws())* eqls() (ws())* (unquoted_value() | quoted_value()))? )+   
}


void attname() :
{
  Token t;
}
{
  (t=<NCNAME> { jjtThis.setNodeData(t.image); }  
  | ( t=<PREFIX> { jjtThis.setPrefix(t.image); }
      t=<NCNAME>) { jjtThis.setNodeData(t.image); })
}

void eqls() :
{
  Token t;
}
{
  t=<EQ> { jjtThis.setNodeData(t.image); } 
}

void unquoted_value() :
{
  Token t;
  StringBuffer s = new StringBuffer();
  
}
{
  ( (t=<UNQUOTED_STRING>) {s.append(t.image);} |
    t=<NCNAME> {s.append(t.image);}
  )+ { jjtThis.setNodeData(s.toString()); } 
}

void quoted_value() :
{
  Token t;
}
{
  t=<STRING_LIT> { jjtThis.setNodeData(t.image); } 
}