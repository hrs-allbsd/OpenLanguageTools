
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.filters.plaintext";
  LOOKAHEAD=7;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(BlockSegmenter_en)

package org.jvnet.olt.filters.plaintext;

// import java.io.*;


public class BlockSegmenter_en {

  /**
   *  A static method to allow the SCCS version of the file to be read at 
   *  runtime.
   */
  public static final String getVersionInfo()
  {
    return "English Segmenter - version: 1.0";
  }

  protected boolean boolParsed = false;

  /**
   *  The method is called by other classes to parse the
   *  current input stream.
   *  @exception  ParseException
   */
  public void parse() throws ParseException 
  {
    //  Call top level rule.
    file();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(BlockSegmenter_enVisitor visitor, Object data) throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }
  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(BlockSegmenter_en)

TOKEN :
{
    <BLANKS: (("\n\n") ("\n")* ) | (("\r\n\r\n") ("\r\n")*)
	/*	"\n" | 
		"\r"*/ 
	     > 
}

TOKEN :
{ 
    <NEWLINE: ("\n") | ("\r\n")> 
}

TOKEN :
{
    <WS: ([" " , "\t", "\r"])+>
}

TOKEN : 
{
    <ELSE: (~[ " ","\n","\r"])+ >
}


void file():
{;}
{
    (newline())? (blanks())?  (block() | eof_block())+
}

void block():
{String s="";}
{
    s=text() (blanks())* {jjtThis.setNodeData(s);}
}

void eof_block():
{String s="";}
{
    s=eof_text() <EOF> {jjtThis.setNodeData(s);}
}


String text():
{Token t;
String s="";
String st="";}
{
    (
     (t=<ELSE> {s+=t.image;} | st=whitespace() {s+=st;})(st=newline() {s+=st;})?

     )+ {return s;}
}

String eof_text():
{Token t;
String s="";
String st="";
}{
    (
     (t=<ELSE> {s+=t.image;} | st=whitespace() {s+=st;})(eof_newline())*

     )+ {return s;}
}



String newline():
{}{ ( <NEWLINE> ){return " ";}
}


// this is to allow newlines at the end of files (thus influencing formatting)
void eof_newline():
{String s="";
 Token t;}{ ( (t=<NEWLINE>{s=t.image;}) | t=<BLANKS> {s=t.image;}){jjtThis.setNodeData(t.image);}
}

String whitespace():
{Token t;
}
{ ( t=<WS> ){ return t.image;}
}

void blanks():
{Token t;
String s="";
}
{
    (t=<BLANKS>) {jjtThis.setNodeData(t.image);}
}
