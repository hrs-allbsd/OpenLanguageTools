
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.laxparsers.software";
  LOOKAHEAD=8;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(LaxSoftwareMessageParser)

package org.jvnet.olt.laxparsers.software;

public class LaxSoftwareMessageParser {

  /**
   *  A static method to allow the SCCS version of the file to be read at 
   *  runtime.
   */
  public static final String getVersionInfo()
  {
    return "English Segmenter - version: 1.0";
  }

  protected boolean boolParsed = false;

  /**
   *  The method is called by other classes to parse the
   *  current input stream.
   *  @exception  ParseException
   */
  public void parse() throws ParseException
  {
    //  Call top level rule.
    message_data();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(LaxSoftwareMessageParserVisitor visitor, Object data) throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }
  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(LaxSoftwareMessageParser)

// Matches TAGs
// Refer to lax parser of SGML doc fragment
TOKEN:
{
  <STAG:           "<"  >
| <ETAG:           "</" >
| <TAGC:           ">"  >
| <EMPTY_TAGC:     "/>" >
}

// Matches the various sequences, including
// "\\", "\'", "\"", "\a", "\b", "\f", "\n", "\r", "\t", "\v", "\000" to "\777" etc.
TOKEN : {       <BACKSLASH:      "\\" > :SLASHMODE }
<SLASHMODE> TOKEN : {       <TWOBACKSLASH:   "\\" > :DEFAULT }
<SLASHMODE> TOKEN : {       <APOSTROPHE:     "\"" > :DEFAULT }
<SLASHMODE> TOKEN : {       <DOUBLEQUOTE:    "\'" > :DEFAULT }
<SLASHMODE> TOKEN : {       <ALERT:          "a"  > :DEFAULT }
<SLASHMODE> TOKEN : {       <BACKSPACE:      "b"  > :DEFAULT }
<SLASHMODE> TOKEN : {       <FORMFEED:       "f"  > :DEFAULT }
<SLASHMODE> TOKEN : {       <NEWLINE:        "n"  > :DEFAULT }
<SLASHMODE> TOKEN : {       <CARRIAGERETURN: "r"  > :DEFAULT }
<SLASHMODE> TOKEN : {       <TAB:            "t"  > :DEFAULT }
<SLASHMODE> TOKEN : {       <VERTTAB:        "v"  > :DEFAULT }
<SLASHMODE> TOKEN : {       <OCTAL:       ["0"-"7"](["0"-"7"])?(["0"-"7"])? > :DEFAULT }
<SLASHMODE> TOKEN : {       <NORMAL: ~["\\","\"","\'","a","b","f","n","0"-"9","r","t","v"] > :DEFAULT }

TOKEN : { <SPACE:       "/\\" > }
TOKEN : { <EMPTY:       "\'\'" | "``" >}



TOKEN :
{
  <#LETTER:     ["a"-"z","A"-"Z"] >
| <#NUM:        ["0"-"9"]         >
| <#NCNAMECHAR: <LETTER> | <NUM> | "." | "-" | "_"  >
| <NAMEWORD:    ( <LETTER> | "_" ) ( <NCNAMECHAR> )*  >
}


// Matches the entity
TOKEN :
{
  <#DEC_HEX_NUM:  ["0"-"9","a"-"f","A"-"F"] >
| <ENTITY:  "&"  // start with an &
            (( <LETTER> )+ | ( "#" ("x")? (<DEC_HEX_NUM>)+)) 
            ";"
  >
}

// Matches the printf formatting convention
// JUST copied from the parser of PrintfParser

// The following token hopefully grabs everything that's a standard
// printf formatting convention : done based on the formats(5) and
// printf(3C) man pages on s10_43
TOKEN :
{   

  <CONV:  "%" // start with a %
          ("-" |  "+" | "#" | "0"  | "\'"  )*         // optional flags
          ("w" | ( "*" | (["0"-"9"])+ ))?             // optional field width specifier
          ( "."  ( "*" | (["0"-"9"])+ ))?             // optional precision specifier
          ( "l" | "ll" | "h" | "L" | "w")?            // optional conversion modifiers
          ("d" | "i" | "o" | "u" | "x" | "X" | "f" |  // conversion characters
           "e" | "E" | "g" | "G" | "c" | "s" | "S" |
           "C" | "p" | "P" | "m" | "n" | "t" )        // not sure what "t" is ?
  >

// this token is a little more complex than the above, in that
// we allow for %n$ to start the formatting string, which lets the user pick which
// printf argument to use (not just the next in line) - we also need to
// allow for the different optional syntax of the field width and precision specifiers
// when this is the case.

| <VARCONV:  ("%" (["0"-"9"])+ "$")                        // start formats with numbered argument
             ("-" |  "+" | "#" | "0" | "\'")*              // optional flags

             (                                             // optional field width
               ( "w" | ( "*" | ("*" (["0"-"9"])+ "$") ) )  // field width when using %n$ or...
             | ( "w" | ( "*" | (["0"-"9"])* ) )            // normal field width specifier
             )? 
             (                                             // optional precision
               ( "." ( "*" | ("*" (["0"-"9"])+ "$") ) )    // precision when we use %n$ or ...
             | ( "." ( "*" | (["0"-"9"])+ )? )             // normal precision
             )? 

             ("l" | "ll" | "h" | "L" | "w")?               // conversion modifiers
             ("d" | "i" | "o" | "u" | "x" | "X" | "f" |    // conversion characters
              "e" | "E" | "g" | "G" | "c" | "s" | "S" |
              "C" | "p" | "P" | "m" | "n" | "t" )          // not sure what "t" is, but it comes up from time to time
  >

| <NULLCONV: ( "%%") > // just prints %
}



TOKEN:
{
  <AMP:            "&"  >
| <PCT:            "%"  >
}


TOKEN:
{
  <DATA:       ( ~["<", "\u0000", "&", "%", ">", "\\", " ", "\r", "\n", "\b", "\f", "\t"] )+  >
| <WHITESPACE: ( [" ", "\r", "\n", "\b", "\f", "\t"] )+  >
}


void message_data() :
{}
{
  (
    open_tag() |
    end_tag()  |
    data()     |
    escape()   |
    entity()   |
    convention() 
  )*
  eof()
}


void open_tag() :
{
  Token t;
  StringBuffer sAcc = new StringBuffer();
  String s    = "";
  String sTag = "";
}
{
  t=<STAG> { sAcc.append( t.image); }
  (
    ( s = white_space() { sAcc.append(s); } )?
    sTag = name()   { sAcc.append(sTag); }
    ( s = tag_data()  { sAcc.append(s); } )?
    ( s = close_tag() { sAcc.append(s); } )?
  )?
  {
    jjtThis.setNodeData(sAcc.toString());
    jjtThis.setTagName(sTag);
  }
}

void end_tag() :
{
  Token t;
  StringBuffer sAcc = new StringBuffer();
  String s    = "";
  String sTag = "";
}
{
  t=<ETAG> { sAcc.append( t.image); }
  (
    ( s = white_space() { sAcc.append(s); } )?
    sTag = name()   { sAcc.append(sTag); }
    ( s = tag_data()  { sAcc.append(s); } )?
    ( s = close_tag() { sAcc.append(s); } )?
  )?
  {
    jjtThis.setNodeData(sAcc.toString());
    jjtThis.setTagName(sTag);
  }
}

String white_space() :
{
  Token t;
}
{
  t=<WHITESPACE> 
  { return t.image; }
}

String name() :
{
  Token t;
}
{
  t=<NAMEWORD>
  { return t.image; }
}

String tag_data() :
{
  String s = "";
  StringBuffer sAcc = new StringBuffer();
}
{
  (
    s=char_data() { sAcc.append(s); }      |
    s=escape_in_tag() { sAcc.append(s); }  |
    s=entity_in_tag() { sAcc.append(s); }
  )+
  { return sAcc.toString(); }
}

String close_tag() :
{
  Token t;
}
{
  ( t=<TAGC> | t=<EMPTY_TAGC> )
  { return (t.image); } 
}

String char_data() :
{
  Token t;
  StringBuffer sAcc = new StringBuffer();
}
{
  (
    t=<DATA>       { sAcc.append( t.image); }  |
    t=<WHITESPACE> { sAcc.append( t.image); }  |
    t=<AMP>        { sAcc.append( t.image); }  |
    t=<PCT>        { sAcc.append( t.image); }  |
    t=<NAMEWORD>   { sAcc.append( t.image); } 
  )+
  { return sAcc.toString(); }
}

void data() :
{
   String s = "";
   StringBuffer sAcc = new StringBuffer();
}
{
  (
    s=char_data() { sAcc.append(s); }   |
    s=close_tag() { sAcc.append(s); }   |
    s=none_escape() { sAcc.append(s); } 
  )+
  { jjtThis.setNodeData(sAcc.toString()); }
}

String none_escape() :
{
  Token t;
  StringBuffer sAcc = new StringBuffer();
}
{
  (
    t=<BACKSLASH>  { sAcc.append( t.image); }  
    ( t=<NORMAL>  { sAcc.append( t.image); }  | t=<EOF> )
  )
  { return sAcc.toString(); }
}

String entity_in_tag() :
{
  Token t;
}
{
  t=<ENTITY> 
  { return (t.image); }
}

String escape_in_tag() :
{
  Token t;
  StringBuffer sAcc = new StringBuffer();
}
{
  (
    t=<BACKSLASH>  { sAcc.append( t.image); }  
    (
      t=<DOUBLEQUOTE>  { sAcc.append( t.image); }  |
      t=<APOSTROPHE>   { sAcc.append( t.image); }
    )
  )
  { return sAcc.toString(); }
}

void escape() :
{
   String s = "";
   StringBuffer sAcc = new StringBuffer();
}
{
  (
    s=slashescape() { sAcc.append(s); } | 
    s=otherescape() { sAcc.append(s); }
  )
  { jjtThis.setNodeData(sAcc.toString()); }
}

String slashescape(): 
{
  Token t;
  StringBuffer sAcc = new StringBuffer();
}
{
  ( 
    t=<BACKSLASH> { sAcc.append(t.image); }
    (
      t=<TWOBACKSLASH> | 
      t=<ALERT>        | 
      t=<BACKSPACE>    |
      t=<FORMFEED>     | 
      t=<NEWLINE>      | 
      t=<OCTAL>        | 
      t=<CARRIAGERETURN> |
      t=<TAB>          | 
      t=<VERTTAB>      |
      t=<APOSTROPHE>   |
      t=<DOUBLEQUOTE>  
    ) { sAcc.append(t.image); }
  )
  { return sAcc.toString(); }
}

String otherescape() : 
{
  Token t;
} 
{
  ( t=<SPACE> | t=<EMPTY> ) 
  { return(t.image); }
}


void entity() :
{
  Token t;
}
{
  t=<ENTITY> 
  
  {
    jjtThis.setNodeData(t.image);
  }
}

void convention() :
{
  Token t;
}
{
  (
    t=<CONV>
  | t=<VARCONV>
  | t=<NULLCONV>
  )
  { jjtThis.setNodeData(t.image); }
}






void eof() :
{
  Token t;
}
{
  t=<EOF> { jjtThis.setNodeData(t.image); }
}

