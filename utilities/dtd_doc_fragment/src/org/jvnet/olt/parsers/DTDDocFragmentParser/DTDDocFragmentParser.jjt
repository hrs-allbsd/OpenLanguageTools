
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.parsers.DTDDocFragmentParser";
  LOOKAHEAD=6;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(DTDDocFragmentParser)

package org.jvnet.olt.parsers.DTDDocFragmentParser;
import org.jvnet.olt.parsers.tagged.*;

/** 
 * this parser isn't at all finished - and really doesn't do much
 * it does detect <!ENTITY...> declaractions, which is all I need it
 * to do - everything else is a work-in-progress and isn't finished.
 * You have been warned.
 */
public class DTDDocFragmentParser
{
  protected boolean boolParsed = false;

  /**
   *  @exception  ParseException
   */
  public void parse()
    throws ParseException
  {
    //  Call top level rule.
    file();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(DTDDocFragmentParserVisitor visitor, Object data)
    throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }

  protected void finalize() throws Throwable
  {
    super.finalize();
  }

   /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(TaggedMarkupVisitor visitor, Object data)
    throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      TaggedMarkupNode node =(TaggedMarkupNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }
 

}

PARSER_END(DTDDocFragmentParser)


//  Tokens

/*  Comments */
MORE :
{
  "<!--" : IN_COMMENT
}

<IN_COMMENT>
TOKEN :
{
  <COMMENT: "-->" > : DEFAULT
}





TOKEN :
{
  <WS : ( " " | "\t" | "\n" | "\f" | "\b" | "\r")+ > 
}

TOKEN :
{
    <ENTITY_DECL: "<!ENTITY"  > : IN_ENTITY_DECL
}

MORE :
{
    "<!NOTATION" : IN_NOTATION_DECL
}

MORE :
{
    "<!ELEMENT" : IN_ELEMENT_DECL
}

MORE :
{
    "<!ATTLIST" : IN_ATTLIST_DECL
}

TOKEN :
{
	<WEIRD_ENT : ("%") ( ~["<" , " " , "\t", "]", "\n", "\r", ";" ] )+ (";")? >
}

<IN_ENTITY_DECL>
TOKEN :
{
    <ENTITY_DECL_NAME: (~[" ","\t","\"","'",">"])+ >
|   <ENT_WS : ( " " | "\t" | "\n" | "\f" | "\b" | "\r")+ > 
|   <ENT_STRING_LIT: "'" ( ~["'"] )* "'" | "\"" ( ~["\""] )* "\""  >
|   <CLOSE_ENTITY_DECL : ">" > : DEFAULT
}


// notation

<IN_NOTATION_DECL>
TOKEN :
{
  <#NOT_STRING_LIT: "'" ( ~["'"] )* "'" | "\"" ( ~["\""] )* "\""  >
|  <NOTATION_DECL : ">" > : DEFAULT
}

<IN_NOTATION_DECL>
MORE : 
{  
  <(  <ENT_STRING_LIT> | ~[">"] )    >
}


// element

<IN_ELEMENT_DECL>
TOKEN :
{
  <#ELEMENT_STRING_LIT: "'" ( ~["'"] )* "'" | "\"" ( ~["\""] )* "\""  >
|  <ELEMENT_DECL : ">" > : DEFAULT
}

<IN_ELEMENT_DECL>
MORE : 
{  
  <(  <ENT_STRING_LIT> | ~[">"] )    >
}

// attlist

<IN_ATTLIST_DECL>
TOKEN :
{
  <#ATTLIST_STRING_LIT: "'" ( ~["'"] )* "'" | "\"" ( ~["\""] )* "\""  >
|  <ATTLIST_DECL : ">" > : DEFAULT
}

<IN_ATTLIST_DECL>
MORE : 
{  
  <(  <ATTLIST_STRING_LIT> | ~[">"] )    >
}

/*  CDATA Sections */
MORE :
{
  "<![CDATA[" : IN_CDATA
}

<IN_CDATA>
TOKEN :
{
  <CDATA: "]]>" > : DEFAULT
}



//  The continuation clauses for the various MORE tokens
<
IN_COMMENT,
//IN_ENTITY_DECL,
IN_CDATA>
MORE :
{
  < ~[] >
}

TOKEN :
{
	<ENTITYREF: "&" ( ~["<" , " " , "\t" , "\n", "\r", ";" ] )+ (";")? >
}

TOKEN :
{
	<PARAMETERENTITYREF: "%" ( ~["<" , " " , "\t" , "\n", "\r", ";" ] )+ (";")? >
}


/*  Tags and bracket tokens */
TOKEN :
{
        <SMARKSECT:  "<!["  >
|       <EMARKSECT:  "]]>"  >
|       <OSQRB:      "["  >
|       <CSQRB:      "]"  >
|       <GT:         ">"  >
|	<PCDATA:     ( ~["<", "\u0000", "&", "%", ">" , "]" , "[", "\r","\n","\b","\f"," ","\t"] )+   >
|       <WHITESPACE: ( ["\r","\n","\b","\f"," ","\t"] )+	>
|	<AMP:	     "&"  >
|	<PCT:	     "%"  > 
}

<TAG>
TOKEN :
{
        <#ALPHA:	["a"-"z","A"-"Z","_","-","."]	>
|	<#NUM:		["0"-"9"]			>
|	<#ALPHANUM:	<ALPHA> | <NUM>			>        
|       <TAGNAME:       <ALPHA> ( <ALPHANUM> )*         >   : ATTLIST 
}



<ATTLIST> TOKEN :
{  <#STRING_LIT: "'" ( ~["'"] )* "'" | "\"" ( ~["\""] )* "\""  >
|  <ATTRIBS:       (  <STRING_LIT> | ~[ ">", "\"", "'" ] )+    >
}




//  Productions
void file() :
{}
{
  (internal_sub_set())
  (eof())
}

void internal_sub_set() :
{}
{
    // internal_sub_set_beginning()
    // (internal_sub_set_ws_comment()) 
  (
   (entity_decl() | notation_decl() | element_decl() | int_entity() | 
    internal_sub_set_ws() | internal_sub_set_comment())
    //(entity_decl()) (internal_sub_set_ws_comment())?
  )*
      // !internal_sub_set_ending()
}


void internal_sub_set_ws() :
{
  Token t;
  String s = "";
}
{
     ( 
       t=<WS>  { 
         s += t.image;   
	 jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
	 jjtThis.setEndPos(t.endLine, t.endColumn, true);
       } 
    )+
    { jjtThis.setNodeData(s);}
}

void internal_sub_set_comment() :
{
  Token t;
  String s = "";
}
{   
     (  t=<COMMENT>      {  
         s += t.image;   
	 jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
	 jjtThis.setEndPos(t.endLine, t.endColumn, true);
       }
     )+
     { jjtThis.setNodeData(s);}
}


// three types of entity declaration we support - we're not supporting them very
// well in the parser (that is, we're not really telling the difference between the different
// token types within the entity (lots of entity_decl_name()) but it'll do for now)
// named_entity_decl
// <!ENTITY Blah "Foo">
// ndata_entity_decl
// <!ENTITY I18NDG PUBLIC "-//Sun::SunSoft//DOCUMENT I18NDG Version 1.0//EN" NDATA sgml>
// parameter_entity_decl
// <!ENTITY % RTthreads "INCLUDE">

void entity_decl() :
{
  Token t;
  String st="";
  String s="";
}
{
  st=entity_decl_begin() { s+=st; }
  (st=entity_decl_space() { s+=st; })+
    ( st=named_entity_decl() { s+=st; } |
      st=ndata_entity_decl() { s+=st; } |
      st=parameter_entity_decl() {s+=st;}
     )
  {
    jjtThis.setNodeData(s);
  }
}

// our standard
// <!ENTITY Foo "blah something else" >
String named_entity_decl() :
{ Token t;
  String s="";
  String st="";
} {
  st=entity_decl_name() { s+=st; }
  (st=entity_decl_space() { s+=st; })+
  st=entity_decl_value() { s+=st; }
  (st=entity_decl_space() { s+=st; })*
  st=entity_decl_close() { s+=st; }
  { return s; }
}

// ndata_entity_decl
// <!ENTITY I18NDG PUBLIC "-//Sun::SunSoft//DOCUMENT I18NDG Version 1.0//EN" NDATA sgml>
String ndata_entity_decl() :
{ Token t;
  String s="";
  String st="";
} {
  // name
  st=entity_decl_name() { s+=st; }
  (st=entity_decl_space() { s+=st; })+
  // public/system
  st=entity_decl_name() { s+=st; }
  (st=entity_decl_space() { s+=st; })+
  // public id/system id
  st=entity_decl_value() { s+=st; }
  (st=entity_decl_space() { s+=st; })*
  // ndata/pcdata/etc.
  st=entity_decl_name() { s+=st; }
  (st=entity_decl_space() { s+=st; })+
  st=entity_decl_name() {s+=st; }
  (st=entity_decl_space() { s+=st; })*
  st=entity_decl_close() { s+=st; }
  { return s; }
}

// parameter_entity_decl
// <!ENTITY % RTthreads "INCLUDE">
String parameter_entity_decl() :
{ Token t;
  String s="";
  String st="";
} {
  // percent
  st=entity_decl_name() { s+=st; }
  (st=entity_decl_space() { s+=st; })+
  // name
  st=entity_decl_name() { s+=st; }
  (st=entity_decl_space() { s+=st; })+
  // value (INCLUDE/IGNORE)
  st=entity_decl_value() { s+=st; }
  (st=entity_decl_space() { s+=st; })*
  st=entity_decl_close() { s+=st; }
  { return s; }
}


String entity_decl_begin() :
{ Token t; String s =""; }
 { t=<ENTITY_DECL> {s=t.image;}
 { jjtThis.setNodeData(s);
   return s;
 }
}

String entity_decl_name() :
{
  Token t;
}
{
  t=<ENTITY_DECL_NAME> {
    jjtThis.setNodeData(t.image); 
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
    return t.image;
  }
}

String entity_decl_space() :
{ Token t; String s =""; }
 { t=<ENT_WS> {s=t.image;}
 { jjtThis.setNodeData(s);
   return s;
 }
}

String entity_decl_value() :
{
  Token t;
}
{
  t=<ENT_STRING_LIT> {
    jjtThis.setNodeData(t.image); 
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
    return t.image;
  }
}

String entity_decl_close() :
{ Token t; String s =""; }
 { t=<CLOSE_ENTITY_DECL> {s=t.image;}
 { jjtThis.setNodeData(s);
   return s;
 }
}


void notation_decl() :
{
  Token t;
}
{
  t=<NOTATION_DECL> {
    jjtThis.setNodeData(t.image); 
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
  }
}

void element_decl() :
{
  Token t;
}
{
  t=<ELEMENT_DECL> {
    jjtThis.setNodeData(t.image); 
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
  }
}

void sgml_data() :
{}
{
    (  
        pcdata() 
       | cdata() 
    )
}



void cdata() :
{
  Token t;
}
{
  t=<CDATA> {
    jjtThis.setNodeData(t.image); 
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
  }
}


/*
void entity() :
{
  Token t;
}
{
  t=<ENTITY> {
    jjtThis.setNodeData(t.image); 
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
  }
}
*/
void int_entity() :
{
  Token t;
}
{
  t=<WEIRD_ENT> {
    jjtThis.setNodeData(t.image);
	jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
	jjtThis.setEndPos(t.endLine, t.endColumn, false);
  }
}

void pcdata() :
{
  Token t;
  String s = "";
}
{
  ( t=<PCDATA>   {
    s = t.image;
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, true);
  } 
    | t=<OSQRB>  {
    s = t.image;
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, true);
  }
    | t=<CSQRB>  {
    s = t.image;
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, true);
  } 
    | t=<GT>     {
    s = t.image;
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, true);
  } 
    | t=<AMP>     {
    s = t.image;
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, true);
  } 
    | t=<PCT>     {
    s = t.image;
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, true);
  } 
    | t=<WHITESPACE>     {
    s = t.image;
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, true);
  } 
  )
  { jjtThis.setNodeData(s); } 
}


void eof():
{}{
   <EOF> 
}

