
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.parsers.MessageFormatParser";
  LOOKAHEAD=4;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}
PARSER_BEGIN(MessageFormatParser)

package org.jvnet.olt.parsers.MessageFormatParser;

/**
 * This parser implements the specification of java MessageFormat strings as
 * specified by the javadocs for java.text.MessageFormat
 * 
 * @author timf
 */
public class MessageFormatParser
{
  protected boolean boolParsed = false;

  /**
   *  @exception  ParseException
   */
  public void parse()
    throws ParseException
  {
    //  Call top level rule.
    file();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(MessageFormatParserVisitor visitor, Object data)
    throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }


  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(MessageFormatParser)



TOKEN : { <TYPE:       "number" | "date" | "time" | "choice" >}
TOKEN : { <STYLE:      "short" | "medium" | "long" | "full" |
                       "integer" | "currency" | "percent" >}

TOKEN : { <COMMA:       ",">}
TOKEN : { <OPENC:       "{">}
TOKEN : { <CLOSEC:      "}">}
// not sure about this one
//TOKEN : { <STRINGLIT: "\'" ~["\'","}"] "\'" >}
TOKEN : { <ESCAPEQUOTE: "\\\"">}
TOKEN : { <DOUBLEQUOTE: "\"">}
TOKEN : { <BACKSLASH: "\\">}
TOKEN : { <QUOTE: "'"> }

TOKEN : {       <NUMBER: (  ["0"-"9"])+ > }

// everything else gets matched by this
TOKEN: {       <WORDS: (~["\'","}","{",",","\\","\""])+ >}  
TOKEN : {       <WS:          (" " | "\n" | "\t" | "\r" | "\b" | "\f" )+ > }

//  Productions
void file() :
{}
{
  (conv() | ws() | words() )*
  eof()
}

void conv() : {
  Token t;
  String s="";
  String st="";
}{  (t=<ESCAPEQUOTE> {s+=t.image;})?
    t=<OPENC> {s+=t.image;} t=<NUMBER> {s+=t.image;}
     (st=type()  {s+=st;})?
     (st=style() {s+=st;})?    
   t=<CLOSEC> {s+=t.image;}
   (t=<ESCAPEQUOTE> {s+=t.image;})?
  { 
    jjtThis.setNodeData(s);  
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
   }
}

String type() : {
  Token t;
  String s="";
}{
    (t=<COMMA> {s+=t.image;} (t=<WS> {s+=t.image;})? t=<TYPE> {s+=t.image;})
 { return s;}
}

String style() : {
  Token t;
  String s="";
 
}{
    t=<COMMA> {s+=t.image;} (t=<WS> {s+=t.image;})? t=<STYLE> {s+=t.image;} 
    (t=<WS> {s+=t.image;})?
 { return s;}
}


void words() : {
  Token t;
}{ (t=<WORDS> | t=<NUMBER> | t=<TYPE> | t=<STYLE>
    | t=<COMMA> | t=<OPENC> | t=<CLOSEC> | t=<QUOTE> | t=<DOUBLEQUOTE> | t=<BACKSLASH>
    | t=<ESCAPEQUOTE>)  {
    {
       jjtThis.setNodeData(t.image);
       jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
       jjtThis.setEndPos(t.endLine, t.endColumn, false);
    }
  }
}

void ws() : {
    Token t;
} { t=<WS> {jjtThis.setNodeData(t.image);}
}

void eof():
{}{
   <EOF> 
}

