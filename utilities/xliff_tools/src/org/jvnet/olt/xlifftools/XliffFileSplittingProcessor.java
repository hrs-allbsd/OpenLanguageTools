/*
* CDDL HEADER START
*
* The contents of this file are subject to the terms of the
* Common Development and Distribution License (the "License").
* You may not use this file except in compliance with the License.
*
* You can obtain a copy of the license at LICENSE.txt
* or http://www.opensource.org/licenses/cddl1.php.
* See the License for the specific language governing permissions
* and limitations under the License.
*
* When distributing Covered Code, include this CDDL HEADER in each
* file and include the License file at LICENSE.txt.
* If applicable, add the following below this CDDL HEADER, with the
* fields enclosed by brackets "[]" replaced with your own identifying
* information: Portions Copyright [yyyy] [name of copyright owner]
*
* CDDL HEADER END
*/

/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

/*
 * File:           XliffFileSplittingProcessor.java
 * Date:           14 July 2003  15:20
 *
 * @author  jc73554
 * @version generated by NetBeans XML module
 */
package org.jvnet.olt.xlifftools;

import org.jvnet.olt.io.HTMLEscapeFilterWriter;
import org.jvnet.olt.xliff.XliffDocument;
import org.jvnet.olt.xliffparser.XliffProcessor;
import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.util.EmptyStackException;
import java.util.Stack;
import org.xml.sax.Attributes;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;


public class XliffFileSplittingProcessor extends XliffProcessorAdaptor {
    
    private XliffDocument xliffDoc;
    
    private Writer outWritter;
    
    private org.jvnet.olt.xlifftools.SplitXliffDocumentListHandler xliffList;

    //number of segments per file
    private int segsPerFile;

    //number of segments processed. Get's reset with each file
    private int segCount=1;
    
    //record all tags up to body tag
    private boolean recording = true;

    //hold all the header tags to be able to build the closing tags (footer)
    private Stack headerStack = new Stack();

    //the footer  and header
    private StringBuffer footer = new StringBuffer();
    private StringBuffer header = new StringBuffer();

    //processing truns-unit inside group ?
    private  boolean inGroup;
    //we record into a StringWritter which is a fake; the stream
    //will later be replaced by a real file
    private boolean fakeWriter = true;


    private static final String docTypeDecl = "<?xml version=\"1.0\"?>\n<!DOCTYPE xliff PUBLIC \"-//XLIFF//DTD XLIFF//EN\" \"http://www.oasis-open.org/committees/xliff/documents/xliff.dtd\" >";
    
    public XliffFileSplittingProcessor(final XliffDocument xliffDoc, org.jvnet.olt.xlifftools.SplitXliffDocumentListHandler xliffList, int unitModulus) {
        this.xliffDoc = xliffDoc;
        this.xliffList = xliffList;
        segsPerFile = unitModulus;

        //initially we'll use StringBuffer
        outWritter = new StringWriter(512);
    }
    

    private void makeNewDoc() throws IOException {
        XliffDocument outputDoc = xliffList.getNewOutputDocument(xliffDoc);
        outWritter = outputDoc.getXliffWriter();
        outWritter.write(docTypeDecl);
        outWritter.write(header.toString());
    }

    private void replaceFakeWriter() throws IOException {
        if(fakeWriter) {
            fakeWriter = false;
            header.append(outWritter.toString());
            makeNewDoc();
        }
    }

    public void start_trans_unit(final Attributes meta) throws SAXException {
        super.start_trans_unit(meta);

        try{
            replaceFakeWriter();
        }
        catch(IOException ioEx) {
            ioEx.printStackTrace();
            throw new SAXException(ioEx);
        }

        //regular end of file; we're not in group
        if( segCount >= segsPerFile && !inGroup){

            //  Create new doc and reset number of segments
            try {
                if(outWritter != null)
                    closeOutDocument(false);
                makeNewDoc();
                segCount = 1;
            }
            catch(IOException ioEx) {
                ioEx.printStackTrace();
                throw new SAXException(ioEx);
            }

        }
        else
            segCount++;
    }




    public void start_group(final Attributes meta) throws SAXException {
        super.start_group(meta);

        try{
            //just in case group is there before trans-unti
            //make sure we don't mess with the header
            replaceFakeWriter();
        }
        catch(IOException ioe){
            throw new SAXException(ioe);
        }

        inGroup = true;
    }


    public void characters(char[] values, int param, int param2) throws SAXException {
        // Wrap characters &, <, and >
        StringWriter stringWriter = new StringWriter();
        
        for(int i = param; i < (param + param2); i++) {
            switch((int)values[i]) {
                case (int) '&':
                    stringWriter.write("&amp;");
                    break;
                case (int) '<':
                    stringWriter.write("&lt;");
                    break;
                case (int) '>':
                    stringWriter.write("&gt;");
                    break;
                default:
                    stringWriter.write(values[i]);
                    break;
            }
        }
        writeText(stringWriter.toString());
    }
    
    public void endDocument() throws SAXException {
        try{
            outWritter.flush();
            outWritter.close();
        }
        catch(IOException ioe){
            throw new SAXException(ioe);
        }
    }
    
    public void endElement(String str, String str1, String str2) throws SAXException {
        if(recording)
            headerStack.pop();

        boolean writeTag = true;
        //If we are in a group tag and we need to save, we will
        if("group".equals(str2)){
            inGroup = false;

            if( segCount >= segsPerFile ){
                //  Create new doc.
                try {
                    if(outWritter != null)
                        closeOutDocument(true);
                    makeNewDoc();
                    segCount = 0;

                    //since we opened another file we don't really want to
                    //write the group tag out
                    writeTag = false;
                }
                catch(IOException ioEx) {
                    ioEx.printStackTrace();
                    throw new SAXException(ioEx);
                }
            }
        }


        if(writeTag){
            try{
                writeCloseTag(str2);
            }
            catch(IOException ioe){
                throw new SAXException(ioe);
            }
        }
    }
    
    public void ignorableWhitespace(char[] values, int param, int param2) throws SAXException {
        writeText(values, param, param2);
    }

    private void makeFooter(){
        if(headerStack.isEmpty())
            throw new IllegalStateException("header stack empty");

        footer = new StringBuffer();
        while(!headerStack.isEmpty()){
            String tag = (String)headerStack.pop();

            footer.append("</").append(tag).append(">\n");
        }

    }

    public void startElement(String str, String str1, String str2, Attributes attributes) throws SAXException {
        //while we've not reached the <body> tag we build the header
        //and stack of tags for footer
        if(recording){
            //record all tags so that we can reconstruct the footer
            headerStack.push(str2);

            //do not record after body
            recording = !"body".equals(str2);

            //we're in the body;
            //- build the footer
            if(!recording){
                makeFooter();
            }
        }


        try{
            writeTag(str2,attributes);
        }
        catch(IOException ioe){
            throw new SAXException(ioe);
        }

    }

    protected void writeText(String text) throws SAXException {
            try {
                //  Write to the output file instead.
                outWritter.write(text);
                outWritter.flush();
            }
            catch(IOException ioEx) {
                ioEx.printStackTrace();
                throw new SAXException(ioEx);
            }
    }

    protected void writeText(char[] values, int start, int length) throws SAXException {
        try {
            //  Write to the output file instead.
            outWritter.write(values, start, length);
        }
        catch(IOException ioEx) {
            ioEx.printStackTrace();
            throw new SAXException(ioEx);
        }
    }

    protected void closeOutDocument(boolean withGroup) throws IOException {
        if(withGroup)
            writeCloseTag("group");

        outWritter.write(footer.toString());
        outWritter.flush();
        outWritter.close();
    }


    private void writeTag(String tag,Attributes attrs) throws IOException{
        outWritter.write("<");
        outWritter.write(tag);

        for(int i = 0; attrs != null && i < attrs.getLength();i++){
            outWritter.write(" ");
            outWritter.write(attrs.getQName(i));
            outWritter.write("=\"");
            outWritter.write(attrs.getValue(i));
            outWritter.write("\"");
        }
        outWritter.write(">");
        outWritter.flush();
    }

    private void writeCloseTag(String tag) throws IOException{
        outWritter.write("</");
        outWritter.write(tag);
        outWritter.write(">");
        outWritter.flush();
    }
}

