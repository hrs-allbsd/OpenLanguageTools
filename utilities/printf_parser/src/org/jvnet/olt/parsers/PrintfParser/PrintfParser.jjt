
/*
 * Copyright  2005 Sun Microsystems, Inc. 
 * All rights reserved Use is subject to license terms.
 *
 */

options{
  NODE_PACKAGE = "org.jvnet.olt.parsers.PrintfParser";
  LOOKAHEAD=2;
  VISITOR = true;
  FORCE_LA_CHECK = true;
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(PrintfParser)

package org.jvnet.olt.parsers.PrintfParser;

/**
 * This parser detects things that appear to be printf-style formatting rules.
 * It's not perfect, but does the job. Actually, most of the work is done in the
 * lexical analysis phase, so this probably doesn't really need the power of JavaCC.
 *
 * Perhaps in the future, I'll create separate parser productions for the various
 * different printf format types (%s, %d, etc.) so that we can find out more information
 * about the things we've parsed. Eg.
 *
 * String : %23d
 * Type = decimal printing
 * Width = 23 chars
 * Precision = not specified
 *
 * but I don't need that stuff for now - just need to be able to detect the printf 
 * tokens themselves.
 * 
 * @author timf
 */
public class PrintfParser
{
  protected boolean boolParsed = false;

  /**
   *  @exception  ParseException
   */
  public void parse()
    throws ParseException
  {
    //  Call top level rule.
    file();
    boolParsed = true;
  }

  /**
   *  walkParseTree:  This method provides an interface to allow node Visitors
   *  to be passed to the parse tree generated by this parser. 
   *  @param  visitor The visitor to act on all the nodes in the parse tree.
   *  @param  data    An object to be used as an aid to the tree walk.
   *  @exception Exception
   */
  public void walkParseTree(PrintfParserVisitor visitor, Object data)
    throws Exception 
  {
    if(boolParsed && (visitor != null))
    {
      //  Get root node of the parse tree
      SimpleNode node =(SimpleNode) jjtree.rootNode();
      node.jjtAccept(visitor, data);
    }
    else
    {
      //  Throw an exception
      throw new Exception("Input stream not parsed");
    }
  }


  protected void finalize() throws Throwable
  {
    super.finalize();
  }
}

PARSER_END(PrintfParser)


TOKEN :
{   

// The following token hopefully grabs everything that's a standard
// printf formatting convention : done based on the formats(5) and
// printf(3C) man pages on s10_43

        <NOCONV:   ( "% ") > // this is to allow for text like "this is 90% done" - don't think
                             // that's valid printf, but it comes up in message files often
                             // when developers aren't formatting strings with printf. Remove
                             // this if you don't need it. Note, that this isn't exhaustive :
                             // "%-Job" as input will throw a Lexical error : but that at least
                             // will tell us that we aren't looking at a printf formatted string.

|       <NULLCONV: ( "%%") > // just prints %
//B.S. 09/2004; match %11-s; this is not a printf format
|       <MSGCONV: ( "%"  (["0"-"9"])+ "-" (["a"-"z"]) " "   )> // something that looks like '%11-s ' we need ingore
//B.S. 09/2004; match regexp: %*[0-9]+  weird,huh ?
|       <REGEXPCONV: ( "%" "*" "[" ( "/" | "^" | "-" | "*" | "+" | (["0"-"9"]) | (["a"-"z"]) )*  "]"   )> // something that looks like '%11-s ' we need ingore
|       <CONV:       "%" // start with a %
					 
					 ("-" |  "+" | "#" | "0"  | "\'"  )* // optional flags
                                               
                     ("w" | ( "*" | (["0"-"9"])+ ))?    // optional field width specifier
                     ( "."  ( "*" | (["0"-"9"])+ ))?  // optional precision specifier
                     
                     ( "l" | "ll" | "h" | "L" | "w")? // optional conversion modifiers
                     ("d" | "i" | "o" | "u" | "x" | "X" | "f" | "C" |  // conversion characters
                      "e" | "E" | "g" | "G" | "c" | "s" | "S" | 
                      "p" | "P" | "m" | "n" | "t" ) // not sure what "t" is ?
                    >

// this token is a little more complex than the above, in that
// we allow for %n$ to start the formatting string, which lets the user pick which
// printf argument to use (not just the next in line) - we also need to
// allow for the different optional syntax of the field width and precision specifiers
// when this is the case.


|       <VARCONV:   ( "%" (["0"-"9"])+ "$") // start formats with numbered argument
                     ("-" |  "+" | "#" | "0" | "\'"  )* // optional flags
                                                            
                                                                  // optional field width
                      (("w" | (("*" (["0"-"9"])+  "$") | "*"))  | // field width when using %n$ or...
                       ("w" | ( "*" | (["0"-"9"])* ))  // normal field width specifier
                      )? 

                      (                                       // optional precision
                       ("." (("*" (["0"-"9"])+ "$") | "*")) | // precision when we use %n$ or ...
                       ("." ((["0"-"9"])+ )? | "*" ) // normal precision
                      )? 

                     ( "l" | "ll" | "h" | "L" | "w" )? // conversion modifiers
                     ("d" | "i" | "o" | "u" | "x" | "X" | "f" | "C" |  // conversion characters
                      "e" | "E" | "g" | "G" | "c" | "s" | "S" | 
                      "p" | "P" | "m" | "n" | "t" ) // not sure what "t" is, but it comes up from time to time
                    > 
}

TOKEN : { <SPACE:       "/\\"> }
TOKEN : { <EMPTY:       "\'\'" | "``">}
TOKEN : { <SLASH:       "/">}

TOKEN : { <APOS: "\'">}
TOKEN : { <BACKTICK: "`">}

// next, we have the other escape sequences that printf allows. Lots of changing
// lexical state here...


// matches the various \n \r etc. sequences
TOKEN : {       <BACKSLASH:   "\\"> :SLASHMODE }
<SLASHMODE> TOKEN : {       <TWOBACKSLASH:   "\\" > :DEFAULT }
<SLASHMODE> TOKEN : {       <ALERT:       "a" > :DEFAULT}
<SLASHMODE> TOKEN : {       <BACKSPACE:   "b" > :DEFAULT}
<SLASHMODE> TOKEN : {       <FORMFEED:    "f" > :DEFAULT}
<SLASHMODE> TOKEN : {       <NEWLINE:     "n" > :DEFAULT}
<SLASHMODE> TOKEN : {       <OCTAL:       ["0"-"9"](["0"-"9"])?(["0"-"9"])? > :DEFAULT}
<SLASHMODE> TOKEN : {       <CARRIAGERETURN: "r" > :DEFAULT}
<SLASHMODE> TOKEN : {       <TAB:         "t" > :DEFAULT}
<SLASHMODE> TOKEN : {       <VERTTAB:     "v" > :DEFAULT}
<SLASHMODE> TOKEN : {       <NORMAL: ~["\\","a","b","f","n","0"-"9","r","t","v"] > :DEFAULT}

// actually, I don't care about whitespace right now
//TOKEN : {       <WS:          (" " | "\n" | "\t" | "\r" | "\b" | "\f" )+ > }

// everything else gets matched by this
TOKEN: {       <WORDS:      (~["%","/","\\","\'","`"])+ >}  

// uncomment for whitespace" ","\n","\t","\r","\b","\f"])+> }

//  Productions
void file() :
{}
{
  (regexpconv() | msgconv() | conv() | variableconv() | nullconv() | escape() | words() )*
  eof()
}

void conv() : {
  Token t;
}{ t=<CONV> {
    jjtThis.setNodeData(t.image);
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
   }
}

void msgconv() : {
  Token t;
}{ t=<MSGCONV> {
    jjtThis.setNodeData(t.image);
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
   }
}

void regexpconv() : {
  Token t;
}{ t=<REGEXPCONV> {
    jjtThis.setNodeData(t.image);
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
   }
}
void variableconv() : {
  Token t;
}{ t=<VARCONV> {
    jjtThis.setNodeData(t.image);
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
   }
}

void nullconv() :{
  Token t;
}{ t=<NULLCONV> {
    jjtThis.setNodeData(t.image);
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
   }
}

/* We're not bothering with calling out whitespace specifically
void ws() : {
  Token t;
}{ t=<WS> {
    jjtThis.setNodeData(t.image);
    jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
    jjtThis.setEndPos(t.endLine, t.endColumn, false);
   }
}
*/


void escape() :{}
{ 
    (slashescape() | otherescape())
}
    
void slashescape(): {
    Token t;
    Token p=null;
    String s="";
} {
    ( p=<BACKSLASH>
     (t=<TWOBACKSLASH> | t=<ALERT> | t=<BACKSPACE> |
      t=<FORMFEED> | t=<NEWLINE> | t=<OCTAL> | t=<CARRIAGERETURN> |
      t=<TAB> | t=<VERTTAB>)){
     if (p!=null){
         s+=p.image;
     }
     jjtThis.setNodeData(s+t.image);
     jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
     jjtThis.setEndPos(t.endLine, t.endColumn, false);
    }
}



void words() : {
  Token t;
  Token p=null;
}{ (t=<WORDS> | t=<SLASH> | t=<APOS> | t=<BACKTICK>
    | t=<NOCONV> | (p=<BACKSLASH> t=<NORMAL>))  {
    if (p==null){
       jjtThis.setNodeData(t.image);
       jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
       jjtThis.setEndPos(t.endLine, t.endColumn, false);
    } else {
       jjtThis.setNodeData(p.image+t.image);
       jjtThis.setBeginPos(p.beginLine, p.beginColumn, false);
       jjtThis.setEndPos(t.endLine, t.endColumn, false);
    }
  }
}

void otherescape() : {
    Token t;
} {
    ( t=<SPACE> | t=<EMPTY>) {
     jjtThis.setNodeData(t.image);
     jjtThis.setBeginPos(t.beginLine, t.beginColumn, false);
     jjtThis.setEndPos(t.endLine, t.endColumn, false);
    }
}

void eof():
{}{
   <EOF> 
}

